{
  "hash": "a493455b699a9032bfaf1831436d2a96",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Writing functions in R\ndate: 2024-06-18\nexecute: \n  echo: true\n  output: \"markup\"\n  freeze: auto\ncategories: [R, intermediate]\n---\n\n\n\n\n:::{.callout-note collapse=false appearance='default' icon=true}\n## Session materials\n+ [all materials {{< iconify ph:file-zip size=2x >}}](src/writing_functions_in_r.zip)\n+ slides [{{< iconify ph:file-html size=2x >}} html](src/writing_functions_in_r_sl.html) / [{{< iconify ph:file-pdf size=2x >}} pdf](src/writing_functions_in_r_sl.pdf)\n:::\n\n\n\n\n::: {.cell layout-align=\"left\"}\n  \n## Previous attendees have said...  \n  \n- 17 previous attendees have left feedback\n- 100% would recommend this session to a colleague\n- 88% said that this session was pitched correctly  \n\n  \n![](writing_functions_in_r_files/figure-html/unnamed-chunk-1-1.png){fig-align='left' width=288}  \n  \n:::{.callout-note}  \n### Three random comments from previous attendees  \n- Good session, as  a R beginner learned some interesting things about how to write functions\n- Interesting content and enough tips and tricks to delight both beginners and intermediate prospective function writers.\n- Presentation was very clear and I was able to check up on an unclear area for me by checking out the slides afterwards. Very useful to see curly brackets & vectorize()\n  \n:::  \n:::\n\n\n\n\n## Welcome!\n\n-   this session is an ðŸŒ¶ðŸŒ¶ **intermediate practical** designed for those with some R experience\n\n## Session outline\n\n+ why functions?\n+ basic syntax\n+ adding arguments\n+ vectorised functions\n+ the mystery of the paired brackets\n+ ...\n\n## Why functions?\n\n+ most beginners write repetitious code\n+ repetitious code is hard to maintain\n+ functions give you an easy way of repeating chunks of code\n\n## Basic syntax\n\n+ think of this as a way of repeating yourself\n+ in time-honoured fashion...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhi_wrld <- function(){\n  \"hello world\"\n}\n\nhi_wrld()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n\n\n## Adding arguments\n\n+ most of the time, you'll want to add **arguments** to your function\n    + add a variable name inside the round bracket of `function`\n    + use that variable name in your function body\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhi_wrld_n <- function(n){\n  paste(rep(\"hello world\", n))\n}\n\nhi_wrld_n(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\" \"hello world\" \"hello world\" \"hello world\"\n```\n\n\n:::\n:::\n\n\n\n\n## Another argument\n\n+ you can add another argument\n+ either position or name can be used in the function call\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhi_name_n <- function(name, n){\n  rep(paste(\"hello\", name) , n)\n}\n\nhi_name_n(\"sue\", 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello sue\" \"hello sue\" \"hello sue\" \"hello sue\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhi_name_n(n = 3, name = \"tango\") # evil but legal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello tango\" \"hello tango\" \"hello tango\"\n```\n\n\n:::\n:::\n\n\n\n\n## Defaults\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhi_name_n_def <- function(n, name = \"janelle\"){\n  rep(paste(\"hello\", name) , n)\n}\n\nhi_name_n_def(n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello janelle\" \"hello janelle\" \"hello janelle\" \"hello janelle\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhi_name_n_def(n = 2, name = \"bruce\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello bruce\" \"hello bruce\"\n```\n\n\n:::\n:::\n\n\n\n\n## Vectorised functions\n\n+ most functions in R are [vectorised](https://bookdown.org/rdpeng/rprogdatascience/vectorized-operations.html)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(c(1.2, 3.2, 5.4, 2.7), 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5 3\n```\n\n\n:::\n:::\n\n\n\n\n+ that means that mostly, our functions will end up vectorised without us doing any work at all\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiv_seven_n_round <- function(nums){\n  round(nums / 7, 0)\n}\n\nnumbers <- rnorm(4, 5, 50)\n\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  20.77928  49.68058 -94.69800  23.20281\n```\n\n\n:::\n\n```{.r .cell-code}\ndiv_seven_n_round(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   3   7 -14   3\n```\n\n\n:::\n:::\n\n\n\n\n+ **but** there are a few cases where that can fail: most famously, using `if`/`else`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even <- function(n){\n  \n  if(n %% 2){\n  paste(n, \"is odd\")\n} else {\n  paste(n, \"is even\")\n}\n  \n}\nis_even(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"9 is odd\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis_even(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10 is even\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(is_even(9:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in if (n%%2) { : the condition has length > 1\n```\n\n\n:::\n:::\n\n\n\n\n## Three solutions\n\n### vectorize with `Vectorize`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even_v <- Vectorize(is_even)\nis_even_v(9:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"9 is odd\"   \"10 is even\"\n```\n\n\n:::\n:::\n\n\n\n\n### apply\n\n+ apply with `lapply` / `purrr::map` with `Vectorize`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(9:10, is_even)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"9 is odd\"\n\n[[2]]\n[1] \"10 is even\"\n```\n\n\n:::\n\n```{.r .cell-code}\npurrr::map(9:10, is_even)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"9 is odd\"\n\n[[2]]\n[1] \"10 is even\"\n```\n\n\n:::\n:::\n\n\n\n\n### refactor\n\n+ refactor to avoid scalar functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even_rf <- function(n){\n  ifelse(n %% 2, paste(n, \"is odd\"), paste(n, \"is even\"))\n}\nis_even_rf(9:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"9 is odd\"   \"10 is even\"\n```\n\n\n:::\n:::\n\n\n\n\n## `{{}}`\n\n### What's the problem?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  dplyr::summarise(average = round(mean(hp)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  average\n1     147\n```\n\n\n:::\n:::\n\n\n\nso\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarmo <- function(column){\n  mtcars |>\n    dplyr::summarise(average = round(mean(column)))\n  }\n```\n:::\n\n\n\n\n+ but...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(carmo(hp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in dplyr::summarise(mtcars, average = round(mean(column))) : \n  â„¹ In argument: `average = round(mean(column))`.\nCaused by error:\n! object 'hp' not found\n```\n\n\n:::\n:::\n\n\n\n> object 'hp' not found\n\n+ we get used to R (and particularly tidyverse) helping us with some sugar when selecting column by their names\n  + `mtcars$hp` / `mtcars |> select(hp)`\n  + effectively, we're just able to specify `hp` like an object, and R figures out the scope etc for us\n+ that misfires inside functions. R isn't sure where to look for an object called `hp`\n\n### Enter `{{}}`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarmo_woo <- function(column){\n  mtcars |>\n    dplyr::summarise(average = round(mean({{column}})))\n}\n\ncarmo_woo(hp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  average\n1     147\n```\n\n\n:::\n:::\n\n\n\n\n+ for 95% of purposes, take `{{}}` as a purely empirical fix\n+ but, if you're very enthusiastic:\n    + `{{}}` [defuses and injects](https://rlang.r-lib.org/reference/topic-metaprogramming.html) the column name\n    + equivalent to `!!enquo(var)`\n    \n## ...\n\n+ pass arbitrary arguments into/through a function with ...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndotty <- function(n, ...){\n  rep(paste(..., collapse = \"\"), n)\n}\n\ndotty(4, letters[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abcde\" \"abcde\" \"abcde\" \"abcde\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Resources\n+ **best = home made!** Refactor something simple in your code today.\n+ hard to beat the treatment of functions in [R4DS](https://r4ds.hadley.nz/functions)\n+ the [Rlang page on data masking](https://rlang.r-lib.org/reference/topic-data-mask.html) is surprisingly sane for such a complicated area\n",
    "supporting": [
      "writing_functions_in_r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}