{
  "hash": "810b394407db1d353dae11e8e50f4f08",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R lists\ndate: 2024-09-05\nexecute: \n  echo: true\n  eval: true\n  output: true\n  freeze: auto\ncategories: [R, beginner, lists, data structures]\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell layout-align=\"left\"}\nNo feedback found for this session\n:::\n\n\n## Introduction\n\n* lists are one of R's built-in data structures\n* lists are roughly equivalent to a vector of vectors\n\n## Make and change lists\n+ list construction can be done in a couple of different ways:\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\"1\", \"2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"1\"\n\n[[2]]\n[1] \"2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nempty <- vector(\"list\", 3L)\nempty\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n```\n\n\n:::\n:::\n\n\n+ you can assign into lists\n\n::: {.cell}\n\n```{.r .cell-code}\nempty[[2]] <- 9\nempty # ironic\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\n[1] 9\n\n[[3]]\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nempty[[2]] <- NULL\nempty # balance restored\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n```\n\n\n:::\n:::\n\n\n+ lists are ordered:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_list <- list(\"one\", \"two\", \"three\")\nsimple_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"one\"\n```\n\n\n:::\n:::\n\n\n## So what's good about lists?\n+ so far, so like vectors\n+ unlike vectors and df/tibbles, lists are **ragged arrays** - can store different lengths and kinds of values together\n+ let's start with some vectors of different types:\n\n::: {.cell}\n\n```{.r .cell-code}\nhw <- \"hello world\"\nhi <- substr(hw, 1, 5)\nhh <- c(hi, hw)\nhcount <- sum(nchar(c(hh, hi, hw)))\ning_things <- factor(c(\"thing\", \"string\", \"wing\", \"bling\"), levels = c(\"wing\", \"bling\", \"string\", \"thing\"))\n```\n:::\n\n\n+ now build a list, and discover that you can store these dissimilar items together\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(hh, hi, hw, ing_things, hcount)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\"       \"hello world\"\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[1] \"hello world\"\n\n[[4]]\n[1] thing  string wing   bling \nLevels: wing bling string thing\n\n[[5]]\n[1] 32\n```\n\n\n:::\n:::\n\n\n## Names\n\n+ you can name list items\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list <- list(\"hh\" = hh, \n                   \"hi\" = hi, \n                   \"hw\" = hw, \n                   \"silly_name\" = ing_things,\n                   \"total_letter_score\" = hcount)\n```\n:::\n\n\n+ it turns out that you already knew that: df/tibbles are a special case of lists. That means that some familiar friends will work with lists - list using `$` to get at named list items:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list$hw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list$hi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"we've got a total of\", named_list$hcount, \"characters in our list, including\", named_list$silly_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"we've got a total of  characters in our list, including thing\" \n[2] \"we've got a total of  characters in our list, including string\"\n[3] \"we've got a total of  characters in our list, including wing\"  \n[4] \"we've got a total of  characters in our list, including bling\" \n```\n\n\n:::\n:::\n\n\n## Indexing lists\n\n+ there's some additional care required when working with indexes and lists though:\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list$hi # a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list[2] # that's a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$hi\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mtcars[2]) # likewise, a 1-column df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n+ two easy ways of getting vectors out of lists\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list$silly_name # like df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list[[2]] # double brackets\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n:::\n\n\n## Unmaking lists\n\n+ if you're not too fussy about the resulting structure, you can flatten a list into a named vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(named_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               hh1                hh2                 hi                 hw \n           \"hello\"      \"hello world\"            \"hello\"      \"hello world\" \n       silly_name1        silly_name2        silly_name3        silly_name4 \n               \"4\"                \"3\"                \"1\"                \"2\" \ntotal_letter_score \n              \"32\" \n```\n\n\n:::\n:::\n\n\n+ each item is named by a concatenation of the original list item name (like \"silly_name\") and an index number - so \"silly_name4\". You can retrieve elements from the vector by these names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(named_list)[\"silly_name4\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsilly_name4 \n        \"2\" \n```\n\n\n:::\n:::\n\n\n+ note that everything has been coerced to character - a reminder that vectors can only contain a single data type \n+ you can also turn a list with equal/similar length items into a tidy array like a tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::tibble(glurt = list(hh, hh, hh)) |>\n  tidyr::unnest_wider(col = glurt, names_sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  glurt_1 glurt_2    \n  <chr>   <chr>      \n1 hello   hello world\n2 hello   hello world\n3 hello   hello world\n```\n\n\n:::\n:::\n\n\n+ things get much more messy when you're dealing with lists with mixed lengths and types. That's beyond us today - have a look at [R for data science](https://r4ds.hadley.nz/rectangling) for an introduction to rectangling\n\n## What are lists for?\n\nLists are particularly useful in three cases:\n\n1. where you don't know what type of output you're going to get. This is the reason that `purrr::map` returns a list by default - you can collect any output type in a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrando <- function(n){\n  ifelse(runif(1) > 0.5, list(n), as.character(n)) # sometimes numeric, sometimes char\n}\nrando(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nc(4,3,rando(8)) # unfortunate coercion that might happen with vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nlist(4,3,rando(8)) # happier and safer in a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4\n\n[[2]]\n[1] 3\n\n[[3]]\n[[3]][[1]]\n[1] 8\n```\n\n\n:::\n:::\n\n\n2. when you've got several related bits of data you want to keep together, especially if you'd like to save them to a single portable object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list |>\n  readr::write_rds(\"data/named_list.rds\")\nrm(list = ls()) # clear environment\n\nnamed_list <- readr::read_rds(\"data/named_list.rds\")\n\nnamed_list |>\n  list2env(envir = .GlobalEnv) # don't tell any proper programmers about this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n3. when you're dealing with wildly complicated data structures. Nice example from [R for data science](https://r4ds.hadley.nz/rectangling#deeply-nested), which is too long-winded for a practical session like this, but a good example of real-world horrible data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepurrrsive::gmaps_cities |> # list columns on list columns\n  tidyr::unnest_wider(col = json) |>\n  tidyr::unnest_longer(col = results) |>\n  tidyr::unnest_wider(col = results) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 7\n  city  address_components formatted_address geometry     place_id types  status\n  <chr> <list>             <chr>             <list>       <chr>    <list> <chr> \n1 Hous… <list [4]>         Houston, TX, USA  <named list> ChIJAYW… <list> OK    \n2 Wash… <list [2]>         Washington, USA   <named list> ChIJ-bD… <list> OK    \n3 Wash… <list [4]>         Washington, DC, … <named list> ChIJW-T… <list> OK    \n4 New … <list [3]>         New York, NY, USA <named list> ChIJOwg… <list> OK    \n5 Chic… <list [4]>         Chicago, IL, USA  <named list> ChIJ7cv… <list> OK    \n6 Arli… <list [4]>         Arlington, TX, U… <named list> ChIJ05g… <list> OK    \n7 Arli… <list [4]>         Arlington, VA, U… <named list> ChIJD6e… <list> OK    \n```\n\n\n:::\n:::\n\n\nAgain, getting beyond the session's aims, but the purrr package is a great help for this kind of nested-nested-nested data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepurrrsive::gmaps_cities |>\n  purrr::pluck(2,1,1,1,\"formatted_address\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Houston, TX, USA\"\n```\n\n\n:::\n:::\n",
    "supporting": [
      "lists_r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}