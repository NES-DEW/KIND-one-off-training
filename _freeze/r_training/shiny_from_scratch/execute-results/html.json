{
  "hash": "a73a852e9030029f194d1fa0d92ac620",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Shiny from scratch\ndate: 2024-07-03\nexecute: \n  echo: true\n  eval: false\n  freeze: auto\noutput: \"markup\"\ncategories: [R, intermediate]\n---\n\n\n:::{.callout-note collapse=false appearance='default' icon=true}\n## Session materials\n+ [sample Shiny script {{< iconify mdi:language-r size=2x >}}](src/app.R)\n\n:::\n\n\n\n::: {.cell layout-align=\"left\"}\n\n:::\n\n\n## Welcome\n\n-   this is an ðŸŒ¶ðŸŒ¶ intermediate-level practical session designed for those with prior R experience, but who are new to Shiny\n-   it's definitely meant to be a taster session, rather than a comprehensive introduction\n\n## Session outline\n\n-   what's the point of Shiny?\n-   resources\n-   `\"hello world!\"`\n-   adding R code\n-   capturing user input\n-   thinking about reactivity\n\n## What's the point of Shiny?\n\n-   a way of publishing interactive R code\n-   here's [a minimal Shiny dashboard](https://l8865y-brendan-clarke.shinyapps.io/shiny_from_scratch/) which we'll build in this session\n\n## Resources\n\n-   you'll need:\n    -   R 4.0+ and Rstudio/posit.cloud/Posit workbench/VSCode\n    -   the `shiny` and `reactlog` packages\n    -   the [Shiny cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/) (essential)\n    -   [Mastering Shiny](https://mastering-shiny.org/) (optional)\n\n## Boilerplate Shiny code\n\n-   start a new R script in an empty project\n-   save as `app.R` (conventional, but helpful)\n-   start typing `shiny`, and select the `shinyapp` snippet to insert the boilerplate Shiny code </br> ![boilerplate Shiny code](images/clipboard-3563940101.png)\n\n## 3 sections\n\n-   `ui`, where you'll build your user interface\n-   `server`, where you'll put the bulk of your R code\n-   `shinyApp`, which collects the `ui` and `server`, and runs your Shiny server\n\n## `\"hello world!\"`\n\n-   now add `\"hello world!\"` in the `ui`</br>![add \"hello world!\" in the ui](images/clipboard-4221183305.png)\n-   `Ctrl` + `Shift` + `Enter` to run your code - or use the run app button ![run app button](images/clipboard-229560138.png)\n-   that should start your Shiny app - and you should see \"hello world!\" in the viewer pane ![](images/clipboard-1464337300.png)\n-   Press stop ![](images/clipboard-20538929.png) - or hit `Esc` to stop your app. You'll need to stop and restart to see changes.\n\n## adding R code\n\n-   now we'll add some simple R code to our `server`. That's going to do something simple with mtcars:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  dplyr::group_by(cyl) |>\n  dplyr::summarise(mpg = round(mean(mpg), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n    cyl   mpg\n  <dbl> <dbl>\n1     4  26.7\n2     6  19.7\n3     8  15.1\n```\n\n\n:::\n:::\n\n\n## `renderTable`, `output$`, and `tableOutput`\n\n-   we'll need to do three things to include this code, and its output, in Shiny\n\n1.  wrap our mtcars code in the `renderTable` function in `server`\n1.  assign that `renderTable` to a variable called `output$my_table`\n1.  finally, replace your `\"hello world!\"` in the `ui` with `tableOutput(\"my_table\")` \n\nYour code should now read:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  tableOutput(\"my_table\")\n)\n\nserver <- function(input, output, session) {\n  output$my_table <- renderTable(mtcars |>\n                dplyr::group_by(cyl) |>\n                dplyr::summarise(mpg = round(mean(mpg), 2)))\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nRun it (`Ctrl` + `Shift` + `Enter`) and you should see a table of mtcars data in the viewer pane: </br> ![table of mtcars data in the viewer pane](images/clipboard-1764561615.png)\n\n## What's going on with `renderX` etc?\n\n+ there are pairs of functions on the [Shiny cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/). Each output type has its own `renderX` function, which you use in the `server` to wrap other kinds of output. So `renderPlot` collects `plot`/`ggplot` output etc.\n\n+ once your output has been rendered, you then save it into a list variable called `output`. Each bit of output needs its own variable name - like `output$my_table`\n\n+ finally, and again from the [Shiny cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/), you extract your data inside the UI from the `output$` variable by using an `XOutput` function that corresponds to your `renderX`\n  \n  \n## capturing user input\n\n+ we need to add three elements to capture user input:\n\n1. add an input widget - like `radioButtons()` above your `tableOutput` in the UI. You'll need to comma-splice that - all your UI contents gets joined with commas\n1. then add an input ID to that input widget `  radioButtons(\"my_input\", \"Which gear to show?\", sort(unique(mtcars$gear)))`\n1. finally, you connect your user input into your code using `input$my_input`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n  output$my_table <- renderTable(mtcars |>\n                dplyr::filter(gear == input$my_input) |>\n                  ...\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}