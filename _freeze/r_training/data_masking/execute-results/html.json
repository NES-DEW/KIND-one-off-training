{
  "hash": "dd83389f4c0e5dc3a43bb6cf55a6b9c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data masking in R\ndate: 2024-09-23\nexecute: \n  echo: true\n  eval: true\n  output: true\n  freeze: auto\ncategories: [R, intermediate, functions, debugging]\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.callout-note collapse=\"false\" appearance=\"default\" icon=\"true\"}\n## Session materials\n\n[Data masking cheatsheet {{< iconify ph:file-pdf size=2x >}}](src/te_cheat_sheet.pdf)\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(NHSRdatasets)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)\n```\n:::\n\n\n\n## Introduction\n\nMore so than in other programming languages, R functions bias towards helping the user do common tasks easily. One excellent example is the way that tidyverse functions (like dplyr) make assumptions about what users mean when they refer to variables. As an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstranded_data |> \n  select(age) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 768 × 1\n     age\n   <int>\n 1    50\n 2    31\n 3    32\n 4    69\n 5    33\n 6    75\n 7    26\n 8    64\n 9    53\n10    63\n# ℹ 758 more rows\n```\n\n\n:::\n:::\n\n\nWhen we specify the age column in this select function, we don't need to tell R that we specifically mean the age column in the `stranded_data` tibble. That's very helpful, because it saves us having to specify that we want to refer to a specific column in a specific tibble each time we write a line of dplyr. Even if we create another tibble that also has an age column...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_stranded_data <- stranded_data |>\n  select(stranded.label, age)\n```\n:::\n\n\n... we can still just refer to the age column of the original `stranded_data` without any risk of confusion. This simplification - which we'll call **data masking** - is a great advantage of using the pipe, and most of the time data masking just works without giving rise to any problems at all. For example, we can write a vector of column names, and then pass it to `select()`, and R will figure out that we want to use those names as column names without any extra effort on our part:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_cols <- c(\"age\", \"care.home.referral\", \"medicallysafe\")\n\nstranded_data |>\n  select(any_of(my_cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 768 × 3\n     age care.home.referral medicallysafe\n   <int>              <int>         <int>\n 1    50                  0             0\n 2    31                  1             0\n 3    32                  0             1\n 4    69                  1             1\n 5    33                  0             0\n 6    75                  1             1\n 7    26                  1             0\n 8    64                  0             1\n 9    53                  0             1\n10    63                  1             0\n# ℹ 758 more rows\n```\n\n\n:::\n:::\n\n\nThat means that cases where data masking goes wrong can be enormously frustrating, because most of the time we don't have to think about what are code is *really* doing very often at all. Here's an example of such a problem in a function that picks a specified column from `stranded_data` and displays it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumn_displayer <- function(col_name) {\n  stranded_data |>\n  select(any_of(col_name)) \n}\n```\n:::\n\n\nIf we try to use this `column_displayer()` function in the normal way, we'll receive an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(column_displayer(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in select(stranded_data, any_of(col_name)) : \n  ℹ In argument: `any_of(col_name)`.\nCaused by error:\n! object 'age' not found\n```\n\n\n:::\n:::\n\n\nOkay, so we can dodge this error in this case by quoting the column name when we supply it as an argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumn_displayer(\"age\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 768 × 1\n     age\n   <int>\n 1    50\n 2    31\n 3    32\n 4    69\n 5    33\n 6    75\n 7    26\n 8    64\n 9    53\n10    63\n# ℹ 758 more rows\n```\n\n\n:::\n:::\n\n\nBut this non-standard [\"kludge\"](https://en.wiktionary.org/wiki/kludge#English) leads to trouble when we want to, for instance, use `column_displayer()` inside another function. A stronger approach is to adjust our function code in the first place, so that we don't have to call our function in a non-standard way (why write *age* in some functions, but *\"age\"* in others to refer to the same thing).\n\nIn this section, we'll give a bit of helpful theoretical background about data masking. We'll then go on to look at four ways of resolving some of the difficulties that data masking can cause.\n\n## Background\n\nThe [rlang page on data-masking](https://rlang.r-lib.org/reference/topic-data-mask.html) is very helpful here in setting out a key distinction between kinds of variables that we've previously been using synonymously:\n\n+ env-variables (things you create with assignment)\n+ data-variables (e.g. imported data in a tibble)\n\nFor beginners, this distinction is not that important, particularly because tidyverse functions do lots of helpful blurring between these different types of variable. Note that many base R functions do often require the user to bear this distinction in mind. For instance, in base R you would specify a data variable differently from an environment variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$cyl      # a data variable\ncyl <- c(4,6,8) # an environment variable\n```\n:::\n\n\nWhereas in tidyverse, you can:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  select(cyl) # specifying a data variable like an environment variable inside select\n```\n:::\n\n\nMost of the time, data masking doesn't cause any problems. However, when you start wanting to include tidyverse functions inside other functions, that blurring raises a problem. We won't give much of an explanation as to the reasons for this, although do read [this introduction to the topic](https://rlang.r-lib.org/reference/topic-data-mask.html) and [this more detailed account](https://rlang.r-lib.org/reference/topic-data-mask-ambiguity.html) if you are interested in the technical aspects. Here, we'll concentrate on four strategies for resolving these kind of data masking problems. These strategies are:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  Problem                              Solution                                 \n  <chr>                                <chr>                                    \n1 data-variable in a function argument **embracing** with `{{var}}`             \n2 env-variable in a vector             `.data[[var]]` and `.env[[var]]` **prono…\n3 variables in output                  **injection** with **`:=`**              \n4 complex cases                        **quasiquotation** with the injection op…\n```\n\n\n:::\n:::\n\n\n\n## Embracing\n\nSlightly confusingly, this practice is also referred to [as *tunneling* data] variables(https://www.tidyverse.org/blog/2020/02/glue-strings-and-tidy-eval/)\n\nIf you want to use a data variable in the argument of a function, you need to ``{{embrace}}`` the argument. Here's some code to produce a rounded mean of a column in `ae_attendances` in cases where breaches are over 100:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_attendances |>\n  filter(breaches > 100) |>\n  pull(attendances) |>\n  mean() |>\n  round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9314.45\n```\n\n\n:::\n:::\n\n\nWe can generalise this to a function, which won't work properly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_means <- function(colname) {\n  ae_attendances |>\n    filter(breaches > 100) |>\n    pull(colname) |>\n    mean() |>\n    round(2)\n}\n\ntry(ae_means(breaches))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in pull(filter(ae_attendances, breaches > 100), colname) : \nCaused by error:\n! object 'breaches' not found\n```\n\n\n:::\n:::\n\n\nHowever, if we embrace the argument in the `pull()` call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_means <- function(colname) {\n  ae_attendances |>\n    filter(breaches > 100) |>\n    pull({{colname}}) |>\n    mean() |>\n    round(2)\n}\n```\n:::\n\n\nWe can use that new function in a standard way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_means(breaches)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1501.65\n```\n\n\n:::\n\n```{.r .cell-code}\nae_means(admissions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2427.32\n```\n\n\n:::\n:::\n\n\nAnd that's worthwhile, because (unlike the non-standard quoted version earlier) we can then use that functions e.g. with `purrr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\norgs <- ae_attendances |> \n        select(where(is.numeric)) |> \n        names()\n\npurrr::map(orgs, ae_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 9314.45\n\n[[2]]\n[1] 1501.65\n\n[[3]]\n[1] 2427.32\n```\n\n\n:::\n:::\n\n\n\n\n## Pronouns\n\nIf you want to use an variable that comes from a character vector, then use **pronouns**. Pronouns allow you to specify how a variable should be interpreted. If we create an atomic vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- c(\"type\")\n```\n:::\n\n\nWe might then try to use this variable inside `count()`, but there are horrors there:\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(ae_attendances |>\n  count(variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in count(ae_attendances, variable) : \n  Must group by variables found in `.data`.\n✖ Column `variable` is not found.\n```\n\n\n:::\n:::\n\n\nIf we now add the `.data[[]]` pronoun:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_attendances |>\n  count(.data[[variable]]) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  type      n\n  <fct> <int>\n1 1      4932\n2 2      1135\n3 other  6698\n```\n\n\n:::\n:::\n\n\nThe `.env[[]]` pronoun works in a similar way. Imagine that we happen to have an env-variable that shares the name of one of our data-variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattendances <- 800\n```\n:::\n\n\nIf we try to use it to filter our data, we'll run into a problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_attendances |>\n  filter(breaches >= attendances) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 6\n# ℹ 6 variables: period <date>, org_code <fct>, type <fct>, attendances <dbl>,\n#   breaches <dbl>, admissions <dbl>\n```\n\n\n:::\n:::\n\n\n(this is based on an actual problem I manufactured for myself while writing the functions training)\n\nThis gives an unexpected result, because there are *definitely* cases where we have more than 800 breaches. In fact we have something like 3598 cases with more than 800 breaches. And what's going on here is that there's an ambiguity - which `attendances` do we mean? This is where pronouns come in, by allowing us to be precise about where the variable is coming from:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_attendances |>\n  filter(.data[[\"breaches\"]] >= .env[[\"attendances\"]]) |> \n  arrange(breaches) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,598 × 6\n   period     org_code type  attendances breaches admissions\n   <date>     <fct>    <fct>       <dbl>    <dbl>      <dbl>\n 1 2016-04-01 RLT      1            5691      800       1023\n 2 2017-10-01 RYR      1           11741      800       3395\n 3 2018-01-01 RC1      1            6162      802       2121\n 4 2018-01-01 RR7      1            7269      802       1810\n 5 2019-02-01 RQX      1            9955      802       1493\n 6 2017-07-01 RWW      1            7094      803       2620\n 7 2019-03-01 RBZ      1            3925      803       1104\n 8 2016-10-01 RJN      1            4234      805        978\n 9 2018-08-01 RNQ      1            7495      805       2596\n10 2016-10-01 RGR      1            5814      806       2017\n# ℹ 3,588 more rows\n```\n\n\n:::\n:::\n\n(you can get away, in this case, without the `.data[[]]`, but included here as an extra example)\n\n\n## Injection\n\n**`:=`** lets you inject variables into your output. For example, to ensure that the name of a new summary column matches a supplied column name in a function, we can inject the variable into the newly-created column name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_means <- function(column, cutoff) {\n\nae_attendances |>\n  filter({{column}} > {{cutoff}}) |>\n  group_by(type) |>\n  summarise(\"mean_{column}\" := round(mean(.data[[column]]), 1)) \n}\n```\n:::\n\n\nThe column name is created using `glue()` syntax. `glue()` is a neat replacement for base-R tools like `paste0()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumn <- c(\"breaches\")\ncutoff <- 400\n\ncat(glue::glue(\"This is how we'd include the column ({column}), and the cutoff ({cutoff}) in Quarto/Rmarkdown using `glue`\")) # easier to read\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis is how we'd include the column (breaches), and the cutoff (400) in Quarto/Rmarkdown using `glue`\n```\n\n\n:::\n:::\n\n\nThe column name is then injected using the `:=` operator. When we call our `col_means()` function, the supplied column name is injected into the new summary column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_means(\"attendances\", 400)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  type  mean_attendances\n  <fct>            <dbl>\n1 1                9391.\n2 2                1549.\n3 other            3575.\n```\n\n\n:::\n:::\n\n\nSimilar injections can be applied across a range of dplyr functions. We'll demonstrate these below using a vector containing the new column name, but injection is most useful when included as part of a function that you might want to apply across several different aspects of your data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_column_name <- c(\"Steve\")\n\nae_attendances |> \n  mutate(\"{new_column_name}\" := round(attendances ^ 0.5, 2) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,765 × 7\n   period     org_code type  attendances breaches admissions Steve\n   <date>     <fct>    <fct>       <dbl>    <dbl>      <dbl> <dbl>\n 1 2017-03-01 RF4      1           21289     2879       5060 146. \n 2 2017-03-01 RF4      2             813       22          0  28.5\n 3 2017-03-01 RF4      other        2850        6          0  53.4\n 4 2017-03-01 R1H      1           30210     5902       6943 174. \n 5 2017-03-01 R1H      2             807       11          0  28.4\n 6 2017-03-01 R1H      other       11352      136          0 107. \n 7 2017-03-01 AD913    other        4381        2          0  66.2\n 8 2017-03-01 RYX      other       19562      258          0 140. \n 9 2017-03-01 RQM      1           17414     2030       3597 132. \n10 2017-03-01 RQM      other        7817       86          0  88.4\n# ℹ 12,755 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nae_attendances |> \n  rename(\"{new_column_name}\" := attendances) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,765 × 6\n   period     org_code type  Steve breaches admissions\n   <date>     <fct>    <fct> <dbl>    <dbl>      <dbl>\n 1 2017-03-01 RF4      1     21289     2879       5060\n 2 2017-03-01 RF4      2       813       22          0\n 3 2017-03-01 RF4      other  2850        6          0\n 4 2017-03-01 R1H      1     30210     5902       6943\n 5 2017-03-01 R1H      2       807       11          0\n 6 2017-03-01 R1H      other 11352      136          0\n 7 2017-03-01 AD913    other  4381        2          0\n 8 2017-03-01 RYX      other 19562      258          0\n 9 2017-03-01 RQM      1     17414     2030       3597\n10 2017-03-01 RQM      other  7817       86          0\n# ℹ 12,755 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nae_attendances |> \n  group_by(org_code) |>\n  summarise(\"{new_column_name}\" := n()) |>\n  arrange(.data[[new_column_name]]) |>\n  slice(1:10) |>\n  ggplot() +\n  geom_col(aes(x=org_code, y=.data[[new_column_name]])) +\n  ggtitle(glue::glue(\"{new_column_name} by org_code\"))\n```\n\n::: {.cell-output-display}\n![](data_masking_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n## Quasiquotation\n\nInformally, the `:=` operator that we explored in the previous subsection functions behaved *as if* it were adding quotes around the variable that was passed to it. That meant that we could pass a quoted variable to a function, and yet return the result as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquoted_variable <- \"Steve\"\n\nae_attendances |> \n  rename(\"{quoted_variable}\" := attendances) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,765 × 6\n   period     org_code type  Steve breaches admissions\n   <date>     <fct>    <fct> <dbl>    <dbl>      <dbl>\n 1 2017-03-01 RF4      1     21289     2879       5060\n 2 2017-03-01 RF4      2       813       22          0\n 3 2017-03-01 RF4      other  2850        6          0\n 4 2017-03-01 R1H      1     30210     5902       6943\n 5 2017-03-01 R1H      2       807       11          0\n 6 2017-03-01 R1H      other 11352      136          0\n 7 2017-03-01 AD913    other  4381        2          0\n 8 2017-03-01 RYX      other 19562      258          0\n 9 2017-03-01 RQM      1     17414     2030       3597\n10 2017-03-01 RQM      other  7817       86          0\n# ℹ 12,755 more rows\n```\n\n\n:::\n:::\n\n\nWhat if we also need to use this variable in an unquoted way? For example, say we now want to use `select()` to pick out our Steve column? \n\nIn a function where an argument is supplied quoted, you can unquote it with `!!`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nae_attendances |> \n  rename(\"{quoted_variable}\" := attendances) |>\n  select(!!quoted_variable) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,765 × 1\n   Steve\n   <dbl>\n 1 21289\n 2   813\n 3  2850\n 4 30210\n 5   807\n 6 11352\n 7  4381\n 8 19562\n 9 17414\n10  7817\n# ℹ 12,755 more rows\n```\n\n\n:::\n:::\n\n\nThat gives us a useful and clear way of thinking about quasiquotation. To borrow the description from the manual page:\n\n> Quasiquotation is the combination of quoting an expression while allowing immediate evaluation (unquoting) of part of that expression. ([rlang quasiquotation manual page](https://www.rdocumentation.org/packages/rlang/versions/0.2.1/topics/quasiquotation))\n\nAnd the strength of using quasiquotation is that it grants lots of scope for handling variables in comparatively complicated function. For example, if we want to create a function to take a supplied tibble and column name, and generate a bit of Rmarkdown with a header and summary of that column, quasiquotation (and injection) allow us to wrangle our variables so that they are compatible with the tidyverse functions that we'd like to use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistinct_entries <- function(df, col_name){\n  \n  cat(glue::glue(\"#### Results for {col_name}:  \\n  \\n\")) # using glue syntax\n  \n  df |> \n    select(!!sym(col_name)) |> # using quasiquotation to select the supplied column\n    rename(\"distinct_{col_name}\" := col_name) |> # using injection to rename the column\n    distinct() \n}\n\ndistinct_entries(ae_attendances, \"org_code\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#### Results for org_code:  \n  \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 274 × 1\n   distinct_org_code\n   <fct>            \n 1 RF4              \n 2 R1H              \n 3 AD913            \n 4 RYX              \n 5 RQM              \n 6 RJ6              \n 7 Y02696           \n 8 NX122            \n 9 RVR              \n10 RJ1              \n# ℹ 264 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [
      "data_masking_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}