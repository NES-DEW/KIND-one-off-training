{
  "hash": "a9b3db894ffa4dc844b3c7e109ff7553",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: stringdist\ndate: 2024-09-23\nexecute: \n  echo: true\n  eval: true\n  output: true\n  freeze: auto\ncategories: [R, intermediate, NLP]\neditor_options:\n  chunk_output_type: console\n---\n\n::: {.cell layout-align=\"left\"}\nNo feedback found for this session\n:::\n\n\n\n## Introduction\nThis is an introduction to [stringdist](https://cran.r-project.org/web/packages/stringdist/stringdist.pdf) which is designed to allow fuzzy matching of text. Install and attach in the standard way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"stringdist\") # likely needs compiling\nlibrary(stringdist) \nlibrary(ggplot2) # for something fun later\n```\n:::\n\n\nWhile there are several families of functions in the package, we'll concentrate on those that focus on the core idea: strings differ, and you can quantify those differences for pleasure and profit. A simple example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thing\", \"think\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(\"thing\", \"string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(\"thing\", \"oxpecker\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\nOnce you've got an idea about how different you're okay with your strings being, you can use e.g. a max distance as a cut-off to do work in your code. A simple example of implementing this can be found in the `amatch` function, which is designed to work like a fuzzy matching version of base-R's `match`. We'll use `a` and `b` as variable names to keep aligned with the stringdist documentation. Quick refresher on `match`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"the\" # take a value\nb <- c(\"this\", \"is\", \"the\", \"thing\") # and a vector of possible values\nmatch(a, b) # match returns the index location of your a in your b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\nMatch lets you do useful work with strings - e.g. remove everything before your key word:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb[match(a, b):length(b)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"the\"   \"thing\"\n```\n\n\n:::\n:::\n\n\n## exemplar: `amatch`\n\nAnd now for the `amatch` version:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"thee\" # take a value\namatch(a, b, maxDist = 1) # maxDist = allowable number of typos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\namatch(a, b, maxDist = 10) # where several possible values exist, amatch returns the closest match\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nYou can use that in a base-R way to e.g. correct wonky input values:\n\n::: {.cell}\n\n```{.r .cell-code}\nb[amatch(a, b, maxDist = 1)] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"the\"\n```\n\n\n:::\n:::\n\n\nOr you might prefer the ain helper:\n\n::: {.cell}\n\n```{.r .cell-code}\nain(a, b, maxDist = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na %in% b # like a fuzzy version of %in%\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"the\" %in% b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nOr in a slightly horrid but tidyish way if you wanted to tidy up several different values:\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::tibble(raw_data = c(\"thi\", \"ss\", \"thee\", \"thung\")) |>\n  dplyr::rowwise() |>\n  dplyr::mutate(is_match = b[amatch(raw_data, b, maxDist = 5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n# Rowwise: \n  raw_data is_match\n  <chr>    <chr>   \n1 thi      this    \n2 ss       is      \n3 thee     the     \n4 thung    thing   \n```\n\n\n:::\n:::\n\n\n## other functions\n\n### `stringdist`, `stringsim`, and `stringdistmatrix`\n`stringdist` has a nice toolkit of related functions. `stringdist` gives you the distance between strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thing\", \"think\") # gives you the raw distance.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(a, b) # vectorised\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 1 3\n```\n\n\n:::\n:::\n\n\n`stringsim` does the opposite, giving a similarity score between 0 and 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringsim(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.50 0.00 0.75 0.40\n```\n\n\n:::\n\n```{.r .cell-code}\nstringsim(\"cat\", \"dog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nstringsim(\"cat\", \"cat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n`stringdistmatrix` does what you might imagine, returning a matrix of differences. This is largely useful if you want e.g. to pass these scores into something like a clustering algorithm that expects a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdistmatrix(a, b) # same idea, different output: a matrix of differences\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    1    3\n```\n\n\n:::\n\n```{.r .cell-code}\nhclust(stringdistmatrix(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nhclust(d = stringdistmatrix(b))\n\nCluster method   : complete \nDistance         : osa \nNumber of objects: 4 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(hclust(stringdistmatrix(b, useNames = \"strings\")))\n```\n\n::: {.cell-output-display}\n![](stringdist_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nIt's possible-but-messy to take this matrix and tidy it into a tibble:\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdistmatrix(c(\"thee\", \"che\"), b, useNames = \"strings\") |>\n  as.data.frame() |>\n  tibble::as_tibble(rownames = \"a\") |> # slightly roundabout conversion to tibble via df to preserve rownames\n  tidyr::pivot_longer(!a, names_to = \"b\", values_to = \"stringdist\") # useful \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  a     b     stringdist\n  <chr> <chr>      <dbl>\n1 thee  this           2\n2 thee  is             4\n3 thee  the            1\n4 thee  thing          3\n5 che   this           3\n6 che   is             3\n7 che   the            1\n8 che   thing          4\n```\n\n\n:::\n:::\n\n\nBut probably better/more idiomatic to go:\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::expand_grid(a = c(\"thee\", \"che\"), b) |>\n  dplyr::mutate(stringdist = stringdist(a, b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  a     b     stringdist\n  <chr> <chr>      <dbl>\n1 thee  this           2\n2 thee  is             4\n3 thee  the            1\n4 thee  thing          3\n5 che   this           3\n6 che   is             3\n7 che   the            1\n8 che   thing          4\n```\n\n\n:::\n:::\n\n\n### `afind`, `grab`, `grabl`, and `extract`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nafind(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$location\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n\n$distance\n     [,1] [,2] [,3] [,4]\n[1,]    2    2    0    3\n\n$match\n     [,1]   [,2] [,3]  [,4]  \n[1,] \"thee\" \"th\" \"the\" \"thee\"\n```\n\n\n:::\n:::\n\n\n`grab` == `grep` and `grabl` == `grepl`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- c(\"wig\", \"win\", \"banana\", \"ring\")\nc[grab(c,  \"wig\", maxDist = 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"wig\" \"win\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc[grab(c,  \"wig\", maxDist = 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"wig\"  \"win\"  \"ring\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrabl(c,  \"wig\", maxDist = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc[grab(c,  \"wig\", maxDist = 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"wig\"    \"win\"    \"banana\" \"ring\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nextract(c, \"wii\", maxDist=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] \n[1,] \"wig\"\n[2,] \"win\"\n[3,] NA   \n[4,] NA   \n```\n\n\n:::\n:::\n\n\n## What do you mean closest?\n\nThe *really* interesting bit: you can play with the method used to calculate distance which will give different results:\n\n### hamming\nHamming distance. Number of character substitutions required to change a into b.\n\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 1, method = \"hamming\") # not found\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 2, method = \"hamming\") # n subs g, g subs n = 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### lv\nLevenshtein distance. Number of del/ins/subs required to change a into b.\n\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"thinng\", b, maxDist = 2, method = \"hamming\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\namatch(\"thinng\", b, maxDist = 2, method = \"lv\") # as we can now delete\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### osa\nOptimal string aligment. Number of del/ins/subs/swaps required to change a into b:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"think\", b, maxDist = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 1, method = \"osa\") # n swaps with g\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### dl\nFull Damerau-Levenshtein distance. As osa, but calculated slightly differently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 1, method = \"dl\") # can't find a difference with these simple ones from osa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### lcs\nLongest common substring distance. Comparing longest identical parts of a and b:\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 2, method = \"lcs\") # I think roughly = length - common substring\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### soundex\nDistance based on soundex encoding. Used in the `phonetic` function (see below), but finds homophones:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namatch(\"thign\", b, maxDist = 1, method = \"soundex\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(\"too\", c(\"two\", \"to\", \"oto\"), method = \"soundex\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1\n```\n\n\n:::\n:::\n\n\nThere are also several methods designed to look at **q-grams** = substring chunks of q characters long, and a group of methods based on the number of similar and different q-grams between a and b:\n\n### qgram\nThis is the q-gram distance:\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thign\", b, method = \"qgram\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5 4 0\n```\n\n\n:::\n:::\n\n\n### cosine\n\nThe cosine distance between q-gram profiles, which gives you (usefully) a scaled distance of between 0 (identical) and 1 (utterly different)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thing\", b, method = \"cosine\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3291796 0.6837722 0.4836022 0.0000000\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(\"thing\", \"fox\", method = \"cosine\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n### jaccard\n\nThe [Jaccard distance](https://en.wikipedia.org/wiki/Jaccard_index) between q-gram profiles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thing\", b, method = \"cosine\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3291796 0.6837722 0.4836022 0.0000000\n```\n\n\n:::\n\n```{.r .cell-code}\nstringdist(\"thing\", b, method = \"jaccard\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5000000 0.8333333 0.6666667 0.0000000\n```\n\n\n:::\n:::\n\n\n### jw\n\nThe Jaro distance (and Jaro-Winkler distance):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringdist(\"thing\", b, method = \"jw\", p = 0.2) # correction term\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.08666667 1.00000000 0.18666667 0.00000000\n```\n\n\n:::\n:::\n\n\n## phonetic\n\nThere's also tooling to deal with the similarity of phonetic spellings. Excellent for e.g. Teams transcripts, if you're trying to tidy those up:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphonetic(\"ring\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"R520\"\n```\n\n\n:::\n\n```{.r .cell-code}\nphonetic(\"wing\") # similar sounding strings get similar values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"W520\"\n```\n\n\n:::\n\n```{.r .cell-code}\nphonetic(\"string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S365\"\n```\n\n\n:::\n\n```{.r .cell-code}\nphonetic(\"strung\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S365\"\n```\n\n\n:::\n:::\n\n\n\n## a play example: GGC\n\nThe KIND network has lots of members from the main NHS body is Glasgow, which is officially known as [\"NHS Greater Glasgow and Clyde\"](https://www.nhsggc.scot/). That's a highly variable and abbreviatable name though, leading to over 70 different permutations in use. Here are some real-ish examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggc <- readr::read_lines(here::here(\"r_training/data/ggc.txt\")) # real data\n\nsample(ggc, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"NHS Greater Glasgow & Clyde\"               \n [2] \"NHS Greater Glasgow & Clyde\"               \n [3] \"NHS GGC\"                                   \n [4] \"GGC NHS Health Improvement - Sexual Health\"\n [5] \"NHSGGC\"                                    \n [6] \"NHS GGC\"                                   \n [7] \"Surgery & Anaesthetics, GG&C\"              \n [8] \"NHS Greater Glasgow and Clyde\"             \n [9] \"HSCP GGC south Glasgow\"                    \n[10] \"Glasgow Caledonian University & NHS GG&C\"  \n```\n\n\n:::\n:::\n\n\nThere's lots here to play with using `stringdist`. My two quick examples are to plot a couple of different methods:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::expand_grid(a = c(\"NHS GGC\", \"NHS Greater Glasgow and Clyde\", \"NHSGGC\"), b = ggc) |>\n  dplyr::mutate(stringdist = stringdist(a, b)) |>\n  ggplot() +\n  geom_density(aes(x = stringdist, fill = a)) +\n  facet_wrap(~a, ncol = 1) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](stringdist_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nOr to try a family tree (more swishily, a [cluster dendrogram](https://www.statisticshowto.com/hierarchical-clustering/)) of those terms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(table(ggc), decreasing = T)[1:7] |>\n  stringdistmatrix(useNames = \"names\") |>\n  hclust() |>\n  plot()\n```\n\n::: {.cell-output-display}\n![](stringdist_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "stringdist_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}