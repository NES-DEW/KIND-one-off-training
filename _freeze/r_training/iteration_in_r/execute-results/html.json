{
  "hash": "9aa80bcf4f86e8293a8968bee1bc6998",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Iteration in R\ndate: 2024-07-05\nexecute: \n  echo: true\n  eval: true\n  output: true\n  freeze: auto\ncategories: [R, intermediate]\n---\n\n::: {.cell layout-align=\"left\"}\n  \n## Previous attendees have said...  \n  \n- 9 previous attendees have left feedback\n- 89% would recommend this session to a colleague\n- 89% said that this session was pitched correctly  \n\n  \n![](iteration_in_r_files/figure-html/unnamed-chunk-1-1.png){fig-align='left' width=288}  \n  \n:::{.callout-note}  \n### Three random comments from previous attendees  \n- Great to reinforce knowledge and always pick up a few tips and tricks along the way.\n- more than enough to spark interest in trying this but some of it clearly melted my brain\n- Excellent introduction to iteration - easy to follow along during the session\n  \n:::  \n:::\n\n\n\n\n## Welcome\n-   this is an ðŸŒ¶ðŸŒ¶ intermediate-level practical session designed for those with prior R experience\n\n\n## Session outline\n- what's a loop?\n- basic examples\n\n## General loop syntax\n\nWe can write a bit of code, and execute it repeatedly. Usually, we'll do this by creating a vector - like `c(1,2,3,4)` - and looping over that vector. We'd do that by writing the following code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (variable in vector) {\n  # some bit of code\n}\n```\n:::\n\n\n\n\n## Simple examples\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:4) {\n  print(\"hello world!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world!\"\n[1] \"hello world!\"\n[1] \"hello world!\"\n[1] \"hello world!\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (i in LETTERS[5:10]) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"E\"\n[1] \"F\"\n[1] \"G\"\n[1] \"H\"\n[1] \"I\"\n[1] \"J\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (i in 4:1) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n## Collecting output\n\nLoops work best when you collect their output by indexing. So we start off by making an empty output vector of the right size, then assigning into that vector within our loop using indexing:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlen <- 1:4\n\noutput <- vector(\"character\", length(len))\n\nfor (i in len) {\n  output[i] <- paste(\"the number is\", i)\n}\n\noutput\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"the number is 1\" \"the number is 2\" \"the number is 3\" \"the number is 4\"\n```\n\n\n:::\n:::\n\n\n\n\nIt's also possible to collect output into a data.frame or similar\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_output <- data.frame(num = vector(\"numeric\", length(len)))\n\nfor (i in 1:4) {\n  df_output$num[i] <- i\n}\n\ndf_output |>\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| num|\n|---:|\n|   1|\n|   2|\n|   3|\n|   4|\n\n\n:::\n:::\n\n\n\n\n## Benchmarking and appending output\n\nYou should avoid appending output. It's inefficient owing to R's [copy-on-modify](https://adv-r.hadley.nz/names-values.html#copy-on-modify) behaviour. We'll set up a couple of loops in a function, and use `microbenchmark` to compare what happens with `append` (which uses `c()` to append its output) with `pre-allocate`, which indexes into a vector of the proper length.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(microbenchmark)\n\nshow_diff <- function(len){\n  output <- vector(\"numeric\", 0)\n  output2 <- vector(\"numeric\", len)\n\nbench <- microbenchmark(append = {\n  for (i in 1:len) {\n    output <- c(output, i)\n                    }\n                                  },\n\npre_allocate = {\n  for (i in 1:len) {\n    output2[i] <- i\n                    }\n                }\n, times = 20)\n\nautoplot(bench) +\n  ggtitle(paste0(\"Loop from 1:\", len))\n}\n```\n:::\n\n\n\n\n\nThe difference isn't that much when dealing with small loops:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_diff(10)\n```\n\n::: {.cell-output-display}\n![](iteration_in_r_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nBut huge differences result very quickly as the loop length increases:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_diff(100)\n```\n\n::: {.cell-output-display}\n![](iteration_in_r_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_diff(500)\n```\n\n::: {.cell-output-display}\n![](iteration_in_r_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n## `seq_along`\n\nThe last tool we'll look at is `seq_along`. This function helps make iterable vectors from other R objects. Say you had a tibble/df that you wanted to iterate over to average each column. You could manually figure out the number of columns, then iterate on that calculation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput <- vector(\"numeric\", length(mtcars))\n\nfor(i in 1:length(output)){\n  output[i] <- mean(mtcars[,i], na.rm=T)\n}\n\noutput\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250\n [7]  17.848750   0.437500   0.406250   3.687500   2.812500\n```\n\n\n:::\n:::\n\n\n\n\nBut, you could alternatively use `seq_along` to generate a neat integer vector to iterate over:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput <- vector(\"numeric\", length(mtcars))\n\nfor(i in seq_along(mtcars)){\n  output[i] <- mean(mtcars[,i], na.rm=T)\n}\n\noutput\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250\n [7]  17.848750   0.437500   0.406250   3.687500   2.812500\n```\n\n\n:::\n:::\n",
    "supporting": [
      "iteration_in_r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}