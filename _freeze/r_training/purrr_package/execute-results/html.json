{
  "hash": "609427cf39d32a430d6a7ee8631e5b2a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The purrr package in R\"\ndate: \"2024-07-29\"\nexecute: \n  echo: true\n  eval: true\n  freeze: auto\noutput: \"markup\"\ncategories: [R, intermediate]\n---\n\n\n::: {.callout-note collapse=\"false\" appearance=\"default\" icon=\"true\"}\n## Session materials\n\n-   [all materials {{< iconify ph:file-zip size=2x >}}](src/purrr_package.zip)\n-   slides [{{< iconify ph:file-html size=2x >}} html](src/purrr_package.html) / [{{< iconify ph:file-pdf size=2x >}} pdf](src/purrr_package.pdf)\n:::\n\n\n\n::: {.cell layout-align=\"left\"}\n  \n## Previous attendees have said...  \n  \n- 2 previous attendees have left feedback\n- 100% would recommend this session to a colleague\n- 100% said that this session was pitched correctly  \n\n  \n![](purrr_package_files/figure-html/unnamed-chunk-1-1.png){fig-align='left' width=288}  \n  \n:::{.callout-note}  \n### Three random comments from previous attendees  \n- The session was a useful introduction to purrr, though I struggled a bit to identify how I might use it in my daily work\n- .\n  \n:::  \n:::\n\n\n\n## Welcome\n\n-   this session is for ðŸŒ¶ðŸŒ¶ intermediate users\n-   you'll need R + Rstudio / Posit Workbench / posit.cloud to follow along\n\n## Session outline\n\n-   a digression about Linnaeus\n-   functionals\n-   base-R functional programming\n-   `map` and `walk`\n-   `map2` and `pmap`\n-   niceties and add-ons\n\n## A digression about Linnaeus\n\n::: columns\n::: {.column width=\"40%\"}\n![[1758 edition of the Systema Naturae](https://www.biodiversitylibrary.org/item/10277)](images/clipboard-4148155250.png){height=\"400\"}\n\n\n:::\n\n::: {.column width=\"60%\"}\n+ used an existing system of binomial classification\n+ *Homo sapiens*\n    + *Homo* = generic name, which applies to similar species\n    + *sapiens* = specific name, for that species and that species only\n+ *Pan troglodytes* and *Pan paniscus* = two similar species in a genus\n+ *Elephas maximus* and *Loxodonta africana* = two similar species in different genera\n\n\n\n:::\n\n:::\n\n## Functionals\n\nHere are some numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn1 <- 7:9\n```\n:::\n\n\n\n\nLet's find their average. We'd usually do this by passing those numbers to a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(n1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\nBut in R, interestingly, we can also do this the other way round by passing a function name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_num_f <- function(funct = mean) funct(n1)\nmy_num_f(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_num_f(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n:::\n\n\nWe'd describe this as a [functional](https://adv-r.hadley.nz/functionals.html). It's fun, but a bit messy and annoying (e.g. how to change the numbers you're averaging??).\n\n## Functional programming in base R\n\nSay we've got a function we want to apply:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_root <- function(n) round(n ^ 0.5, 1)\n```\n:::\n\n\nThere are several ways of applying functions to stuff in base R. \n+ we could use a loop: that's another session\n+ we could just exploit the vectorised nature of most functions in R\n\n::: {.cell}\n\n```{.r .cell-code}\nround_root(n1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.6 2.8 3.0\n```\n\n\n:::\n:::\n\n\n+ or we could use some of the `apply` family of functions, like `lapply` and `sapply`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(n1, round_root) # returns a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6\n\n[[2]]\n[1] 2.8\n\n[[3]]\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(n1, round_root) # simplifies that list to a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.6 2.8 3.0\n```\n\n\n:::\n:::\n\n\nThere's no real reason to use these functions when things are this simple, but when our applications become more complicated...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn2 <- 11:13\n\nlapply(list(n1, n2), round_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6 2.8 3.0\n\n[[2]]\n[1] 3.3 3.5 3.6\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(list(n1, n2), round_root) # oddball output\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  2.6  3.3\n[2,]  2.8  3.5\n[3,]  3.0  3.6\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(list(n1, n2[1:2]), round_root) # quirky\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6 2.8 3.0\n\n[[2]]\n[1] 3.3 3.5\n```\n\n\n:::\n:::\n\n\n## purrr\n\n+ [purrr](https://cran.r-project.org/web/packages/purrr/index.html) is a functional programming toolkit\n+ main advantage = **consistency**\n+ [very useful cheatsheet](https://rstudio.github.io/cheatsheets/html/purrr.html)\n\n## `map`\n\n`map` is our purrr [type specimen](https://en.wikipedia.org/wiki/Type_(biology))\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nmap(n1, round_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6\n\n[[2]]\n[1] 2.8\n\n[[3]]\n[1] 3\n```\n\n\n:::\n:::\n\n\nPleasingly, `map` will handle all kinds of odd inputs without fuss:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(n1, n2), round_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6\n\n[[2]]\n[1] 2.8\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 3.3\n\n[[5]]\n[1] 3.5\n\n[[6]]\n[1] 3.6\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(dplyr::tibble(n1 = n1, n2 = n2), round_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$n1\n[1] 2.6 2.8 3.0\n\n$n2\n[1] 3.3 3.5 3.6\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(rbind(n1, n2), round_root) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2.6\n\n[[2]]\n[1] 3.3\n\n[[3]]\n[1] 2.8\n\n[[4]]\n[1] 3.5\n\n[[5]]\n[1] 3\n\n[[6]]\n[1] 3.6\n```\n\n\n:::\n:::\n\n\n`map` will always return a list - that's because, no matter what the output, you can always cram it into a list. If you want different output, you can have it. You just need to find the right *species*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(n1, round_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.6 2.8 3.0\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(map_int(n1, round_root)) # surly and strict\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in map_int(n1, round_root) : â„¹ In index: 1.\nCaused by error:\n! Can't coerce from a number to an integer.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nround_root_int <- function(n) as.integer(n ^ 0.5)\nmap_int(n1, round_root_int) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nround_root_lgl <- function(n) as.integer(n ^ 0.5) %% 2 == 0\nmap_lgl(n1, round_root_lgl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n## anonymous functions\n\nIf you're comfortable with the new anonymous function syntax, you can build an anonymous function in place:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_lgl(1:4, \\(x) x %% 2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n## `walk`\n\n`walk` is intended for code where the side-effect is the point: graphs, pipes, and Rmarkdown especially. Otherwise, it's as `map`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk(n1, round_root) # wtf?\nround_root_print <- function(n) print(n ^ 0.5)\nwalk(n1, round_root_print) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.645751\n[1] 2.828427\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nround_root_cat <- function(n) cat(n ^ 0.5, \"  \\n\")\nwalk(n1, round_root_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.645751   \n2.828427   \n3   \n```\n\n\n:::\n:::\n\n\n\n## `map2` \n\n`map2` is for 2-argument functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_int(n1, n2, `+`) # the best terrible way of adding I know\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 20 22\n```\n\n\n:::\n\n```{.r .cell-code}\nround_root_places <- function(n, dp = 1) round(n ^ 0.5, dp)\nround_root_places(n1, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmap2(n1, 0, round_root_places)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 3\n```\n\n\n:::\n:::\n\n\n## Beware of recycling rules\n\nYou'll be unable to use `map2` if your inputs are different lengths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(map2(1:3, 0:3, round_root_places))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in map2(1:3, 0:3, round_root_places) : \n  Can't recycle `.x` (size 3) to match `.y` (size 4).\n```\n\n\n:::\n:::\n\n\nThis makes `expand.grid` valuable if you're looking to try out all the combinations of two vectors, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- expand.grid(nums = 1:3, dplaces = 0:3) \n\nmap2(dat$nums, dat$dplaces, round_root_places)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 2\n\n[[4]]\n[1] 1\n\n[[5]]\n[1] 1.4\n\n[[6]]\n[1] 1.7\n\n[[7]]\n[1] 1\n\n[[8]]\n[1] 1.41\n\n[[9]]\n[1] 1.73\n\n[[10]]\n[1] 1\n\n[[11]]\n[1] 1.414\n\n[[12]]\n[1] 1.732\n```\n\n\n:::\n:::\n\n\nOr (probably more usefully) this could be done inside `dplyr::mutate` to add to a tibble:\n\n\n\n```{.r .cell-code}\nexpand.grid(nums = n1, dplaces = 0:3) |>\n  dplyr::as_tibble() |>\n  dplyr::mutate(rr = map2_vec(nums, dplaces, round_root_places)) |>\n  knitr::kable()\n```\n\n\n\n| nums| dplaces|    rr|\n|----:|-------:|-----:|\n|    7|       0| 3.000|\n|    8|       0| 3.000|\n|    9|       0| 3.000|\n|    7|       1| 2.600|\n|    8|       1| 2.800|\n|    9|       1| 3.000|\n|    7|       2| 2.650|\n|    8|       2| 2.830|\n|    9|       2| 3.000|\n|    7|       3| 2.646|\n|    8|       3| 2.828|\n|    9|       3| 3.000|\n\n\n## `pmap`\n\n`pmap` is for n argument functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_roots_places <- function(n, root = 2, places = 1) round(n ^ 1/root, places)\n\nround_roots_places(n1, root = 4, places = 2) # use named arguments to avoid misery\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.75 2.00 2.25\n```\n\n\n:::\n\n```{.r .cell-code}\npmap(list(n = n1, root = 4, places = 2), round_roots_places)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1.75\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 2.25\n```\n\n\n:::\n:::\n\n\n## Niceties and addons\n\n`imap` allows you to work with indicies, and `list_c` converts simple lists back to vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimap(list(\"a\", \"b\", \"c\"), \\(x, y) paste0(y, \": \", x)) |> # index map where y is the name or index\n  list_c()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1: a\" \"2: b\" \"3: c\"\n```\n\n\n:::\n:::\n\n\nIf your function returns a tibble, you can use `list_rbind` or `list_cbind` to row- or column-bind the results into a tibble:\n\n\n\n```{.r .cell-code}\nmap(n1, \\(x) dplyr::tibble(\"Val\" = x, \"sq_val\" = x^2)) |>\n  list_rbind() |>\n  knitr::kable()\n```\n\n\n\n| Val| sq_val|\n|---:|------:|\n|   7|     49|\n|   8|     64|\n|   9|     81|\n\n\n## Resources\n\n- [functionals chapter in Advanced R](https://adv-r.hadley.nz/functionals.html)\n- [purrr cheatsheet](https://rstudio.github.io/cheatsheets/html/purrr.html)",
    "supporting": [
      "purrr_package_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}