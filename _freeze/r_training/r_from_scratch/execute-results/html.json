{
  "hash": "26a396c1af9a0fcfdccc11b4f98495cd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R from scratch\"\ndate: 2024-09-24\nexecute: \n  echo: true\n  eval: true\n  freeze: auto\n  output: \"markup\"\ncategories: [R, beginner]\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell layout-align=\"left\"}\n  \n## Previous attendees have said...  \n  \n- 52 previous attendees have left feedback\n- 100% would recommend this session to a colleague\n- 96% said that this session was pitched correctly  \n\n  \n![](r_from_scratch_files/figure-html/unnamed-chunk-1-1.png){fig-align='left' width=288}  \n  \n:::{.callout-note}  \n### Three random comments from previous attendees  \n- Very well presented and accessible introduction to R. I enjoyed it.\n- I think it was a bit fast paced.\n- Good session but difficult to keep up when trying to copy out the code\n  \n:::  \n:::\n\n\n\n\n# Getting started\n\n-   you'll need some kind of R setup for this training\n    -   if you already have some type of R installation available (PHS workbench, Rstudio desktop etc) please feel free to use that\n    -   otherwise, create a free account on [posit.cloud](https://posit.cloud/ \"https://posit.cloud/\")\n-   Then confirm that you're able to log-in to that account using the device and the network connection that you're going to be using during the training session. Of note, some board VPNs (PHS, Lothian, couple of others) seem to cause trouble, and it can take a bit of time to work out fixes and workarounds.\n-   Once logged in, please attempt a 2 minute test (below) so that we can be sure everything will be in working order before the first training session:\n\n::: {.callout-note collapse=\"true\" appearance=\"default\" icon=\"true\"}\n## Testing your Posit Cloud\n\n1.  sign in to your account at <https://posit.cloud/>\n2.  create a New RStudio Project from the big blue button</br> ![create a New RStudio Project](images/clipboard-1870431838.png)\n3.  after 30 seconds or so you should have a new R project open in front of you</br>![new R project](images/clipboard-3686794244.png)\n4.  in the console - the bottom-left part of the window with all the text in - please type `demo(image)` at the `>` prompt and press enter\n5.  keep pressing enter until you see graphs start appearing (2-3 times should do it)</br>![demo plots](images/clipboard-984098222.png)\n:::\n\n::: panel-tabset\n# Session 1: \"hello world\"\n\n## hello world\n\n-   R has a terminal where you can write code, and R will run it for you and show you the results\n-   we'll start with a string, which is how we keep words in R code (single or double quotes, your choice)\n-   type a string in the terminal\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n\n\n</br> ![\"hello world\" in the terminal](images/clipboard-1008380297.png)\n\n-   but we usually write R in script files\n-   start a new R script</br>![New R script](images/clipboard-4056129341.png)\n-   now press `Ctrl` + `Enter` to run your script\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n\n\n-   (for the coders, R has implicit print)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# variable\n# assignment operator\nhw <- \"hello world\"\nhw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# R is case sensitive\n# R runs from top to bottom - you can't use an object until you've made it\ntry(HW) # a way of running broken code and capturing the error messages it provokes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in eval(expr, envir, enclos) : object 'HW' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nHW <- \"HELLO WORLD\"\nHW\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO WORLD\"\n```\n\n\n:::\n:::\n\n\n\n\n## functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print function\n# variables persist\nprint(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# help for all functions\n?print\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# look at the help and try to make substr work to pull out \"hello\"\n# arguments\nsubstr(hw, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# return value\n# assign out of functions\nhi <- substr(hw, 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# combine\nc(hw, hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\" \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(c(hw, hw))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# most functions are vectorised\nsubstr(c(hw, hw), 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhh <- substr(c(hw, hw), 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# especially nice for maths stuff\n# logic\nc(4,3,7,55) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   8   6  14 110\n```\n\n\n:::\n\n```{.r .cell-code}\nc(4,3,7,55) > 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexing\n# range operator\nhh[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"  \"indexing\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#length\n# typeof\nlength(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n## data types and classes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# homogenous - only one kind of thing per vector\ntypeof(\"this is a string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# factors - the odd one\n# mainly a way of storing categorical data, especially when you need it in non-alphabetical order\nfactor(c(\"thing\", \"string\", \"wing\", \"bling\")) # alphabetical\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: bling string thing wing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things <- factor(c(\"thing\", \"string\", \"wing\", \"bling\"), levels = c(\"wing\", \"bling\", \"string\", \"thing\")) # alphabetical\ning_things\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] string\nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the list = a vector of vectors\n# ragged - can store different kinds of values together\nlist(hh, hi, hw, ing_things)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\" \"hello\"\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[1] \"hello world\"\n\n[[4]]\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# names\nnamed_list <- list(\"hw\" = hh, \n                   \"hi\" = hi, \n                   \"hw\" = hw, \n                   \"silly_name\" = ing_things)\nnamed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$hw\n[1] \"hello\" \"hello\"\n\n$hi\n[1] \"hello\"\n\n$hw\n[1] \"hello world\"\n\n$silly_name\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different indexing required for lists\nclass(named_list[4]) #gets you a smaller list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# two easy ways of getting vectors out of lists\nnamed_list$silly_name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list[[4]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# and you can flatten a list into a vector\nunlist(named_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          hw1           hw2            hi            hw   silly_name1 \n      \"hello\"       \"hello\"       \"hello\" \"hello world\"           \"4\" \n  silly_name2   silly_name3   silly_name4 \n          \"3\"           \"1\"           \"2\" \n```\n\n\n:::\n:::\n\n\n\n\n# Session 2: core function toolkit\n\n## session 1 reminders\n\n-   console vs script (`Ctrl` + `⏎`)\n-   assign values to variables with `<-`\n-   vectors = simplest R data structure (like an ordered group)\n-   functions = R verbs that:\n    -   are case-sensitive, whitespace-insensitive\n    -   have arguments (roughly = options)\n    -   return results\n    -   are usually vectorised (so can be used over all members of a vector)\n\n### make some play data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\nnumbers <- c(3,6,5,4,3)\nstring <- \"just a string\"\nlonger_string <- c(\"this\", \"is\", \"a\", \"length\", \"seven\", \"character\", \"vector\")\n```\n:::\n\n\n\n\n## core numeric operators and functions\n\n### arithmetic\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers * 5 # they're vectorised\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 30 25 20 15\n```\n\n\n:::\n\n```{.r .cell-code}\n4 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.333333\n```\n\n\n:::\n\n```{.r .cell-code}\n5 - numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 -1  0  1  2\n```\n\n\n:::\n\n```{.r .cell-code}\n8 ^ 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.828427\n```\n\n\n:::\n:::\n\n\n\n\n### range operator\n\nThe range operator is an easy way of making integer sequences:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n5:2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 3 2\n```\n\n\n:::\n:::\n\n\n\n\nThere's always a fancier way too:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1,3,0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0\n```\n\n\n:::\n:::\n\n\n\n\n### equals/inequality\n\nReally important for lots of programming things\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\na == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na < 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na >= 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na != 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers[numbers > 3] # filtering with equalities/inequalities\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 5 4\n```\n\n\n:::\n:::\n\n\n\n\n### fancy operator bits\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 %% 3 # remainder / modulo for remainder-after-division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n5 %/% 3 # integer division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n### core numeric functions\n\nNote that most of these functions are vectorised, but will require you to use `c()` if you want to supply your values directly (i.e. if you don't want to make a variable containing your values first). `sum()` is a rare exception:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1,5,10) # works okay\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(c(1,5,10)) # but this works fine too, and is easy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(c(1,5,10)) # and is the general way you'll need to work if you're supplying values directly to the function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.333333\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(a) # square root\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\ncumsum(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  9 14 18 21\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(numbers) # square roots\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.732051 2.449490 2.236068 2.000000 1.732051\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(numbers) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\nFor odd reasons, there's no built-in function to find the statistical mode of some numbers. It can be done, but the code is ugly (and exactly the sort of thing we'd usually avoid in beginner's sessions). Included here for interest only:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mode\nas.numeric(names(sort(-table(numbers)))[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nThere are also a few other fairly basic functions that you might find helpful:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(numbers) # standard deviation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.30384\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(numbers) # min and max in one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(numbers) # good for rapid numeric summaries\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    3.0     3.0     4.0     4.2     5.0     6.0 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(numbers) # good for finding out what you've got in more complicated vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumbers\n3 4 5 6 \n2 1 1 1 \n```\n\n\n:::\n:::\n\n\n\n\n## interlude: joining code together\n\nThere are three main ways of doing this. Traditionally, you'd bracket together several functions, and read from the inside out. Fastest to write, hardest to read and fix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(sqrt(c(1,5,10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\nor you can make intervening variables. Messy, but good if you need to be extra careful:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- c(1,5,10)\no <- sqrt(n)\np <- round(o)\np\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\nor, probably the best way, pipe the code together. `Ctrl` + `Shift` + `m` will give you a pipe symbol:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,5,10) |>\n  sqrt() |>\n  round()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\nNote that the pipe method doesn't automatically save your output. You'll need to assign with `<-` to do that:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- c(1,5,10) |>\n  sqrt() |>\n  round()\n\ntemp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n## basic string functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntoupper(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO WORLD\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntolower(longer_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this\"      \"is\"        \"a\"         \"length\"    \"seven\"     \"character\"\n[7] \"vector\"   \n```\n\n\n:::\n\n```{.r .cell-code}\ntoupper(longer_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"THIS\"      \"IS\"        \"A\"         \"LENGTH\"    \"SEVEN\"     \"CHARACTER\"\n[7] \"VECTOR\"   \n```\n\n\n:::\n\n```{.r .cell-code}\npaste(hw, hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(string, \"ed instrument\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"just a string ed instrument\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(\"question \", numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"question 3\" \"question 6\" \"question 5\" \"question 4\" \"question 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(hw, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"hello world\" \"hello world\" \"hello world\" \"hello world\" \"hello world\"\n [6] \"hello world\" \"hello world\" \"hello world\" \"hello world\" \"hello world\"\n```\n\n\n:::\n:::\n\n\n\n\n## a few more interesting string functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrsplit(hw, \" \") # split a string into pieces and get a list back\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\" \"world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstrsplit(hw, \" \") |> # split and unlist back to vector\n  unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"world\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"seven\", longer_string) # tell me where in a vector a search term is found\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\ngrepl(\"seven\", longer_string) # tell me if a vector contains a search term\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsort(longer_string) # into alphabetical order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"         \"character\" \"is\"        \"length\"    \"seven\"     \"this\"     \n[7] \"vector\"   \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(longer_string) # as with numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlonger_string\n        a character        is    length     seven      this    vector \n        1         1         1         1         1         1         1 \n```\n\n\n:::\n:::\n\n\n\n\n# Session 3: functions, loops, and flow\n\nDon't repeat your code. Long code is hard to read and understand. Three basic design patterns: the function, the loop, the if/else.\n\n## write a function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic function syntax\n# need to run the definition before calling it\n\nfunction_name <- function(argument){\n  # some code doing something to the argument\n  argument + 4 # the function will return the last value it produces\n}\n\nfunction_name(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# challenge - I'm bored of writing na.rm = TRUE. Could you make mean() automatically ignore the missing values?\n\nnew_mean <- function(x){\n  mean(x, na.rm = TRUE)\n}\n\nnew_mean(c(1,4,2,4,NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.75\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# arguments and defaults\n# simple function syntax without {}\n\nmulto <- function(n1, n2 = 7) n1 * n2\n\nmulto(3)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\nmulto(3, 6)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# anonymous function syntax is useful, but way too evil for a beginner's course\n\n(\\(x) x^2)(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n\n```{.r .cell-code}\n(\\(x, y) x^y)(5,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 125\n```\n\n\n:::\n:::\n\n\n\n\n## write a loop\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic syntax \nfor(i in 1:5){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# seq_along as a sensible safe way to work with vectors\nfor(i in seq_along(numbers)){ # seq_along converts a vector into sequential integers 1,2,3,4... up to the length of the vector\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexing is the key to working with vectors inside loops\nfor(i in seq_along(numbers)){\n  print(numbers[i]) # with indexing\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n[1] 6\n[1] 5\n[1] 4\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# need to create output first, then collect\n\nloop_output <- vector(mode = \"numeric\", length = length(numbers))\n\nfor(i in seq_along(numbers)){\n  loop_output[i] <- numbers[i] * 9 # insert each bit of output into the right place in the output vector\n}\n\nloop_output\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27 54 45 36 27\n```\n\n\n:::\n:::\n\n\n\n\n## write an if/else\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic syntax\na <- 3\n\nif(a == 3){\n  \"a is three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a is three\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# even easier if your condition is logical\nc <- TRUE\n\nif(c){\n  \"c is true\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"c is true\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# combine conditions\nb <- 2\n\nif(a == 3 | b == 3){\n  \"a and/or b are three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a and/or b are three\"\n```\n\n\n:::\n\n```{.r .cell-code}\nif(a == 3 & b == 3){\n  \"a and/or b are three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nope\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- c(4,3)\n\nif(d == 3){\n  \"if/else isn't vectorised\"\n} else {\n  \"so this won't work\"\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the ifelse type if you need vectorised if/else\nd <- c(4,3)\n\nifelse(d == 3, \"...and we'll get this one second\", \"the first item is false, so we'll get this first\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"the first item is false, so we'll get this first\"\n[2] \"...and we'll get this one second\"                \n```\n\n\n:::\n:::\n\n\n\n\n# Session 4: packages and dplyr\n\nWe can bring in external code to help us with R. That external code is known as a package. There are thousands of packages in current use, as the [relevant pages on CRAN will tell you](https://cran.r-project.org/web/packages/available_packages_by_date.html).\n\n## penguins\n\nWe need to install packages before we can use them. That only needs to be done once for your R setup. To illustrate, let's install a package, called [palmerpenguins](https://allisonhorst.github.io/palmerpenguins/), which contains some interesting data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"palmerpenguins\")\n```\n:::\n\n\n\n\nOnce that package is installed, we can use the data (and functions) it contains by attaching them to our current script:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n\nOnce we've done that, we'll have several new items available to use. The most important here is the main `penguins` dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n\n\nThat's tabular data - so formed into rows and columns, rectangular (so all columns the same lengths etc), and with each column containing only one type of data. Tabular data is probably the most widely used type of data in R. That means that there are lots of tools for working with it. Some basic examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 344\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"species\"           \"island\"            \"bill_length_mm\"   \n[4] \"bill_depth_mm\"     \"flipper_length_mm\" \"body_mass_g\"      \n[7] \"sex\"               \"year\"             \n```\n\n\n:::\n:::\n\n\n\n\n## dplyr\n\nAs well as those base-R functions, there are also many packages for working with tabular data. Probably the best-known package is [dplyr](https://dplyr.tidyverse.org/), which we install and attach in the same way as `palmerpenguins`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n\nThe reason that `dplyr` is so popular is that some of the base-R ways of working with tabular data are a bit messy and hard to read:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins$species[1:4] # just to show the first few\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Adelie Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins[[\"island\"]][1:4] # just the first few, again\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Torgersen Torgersen Torgersen Torgersen\nLevels: Biscoe Dream Torgersen\n```\n\n\n:::\n:::\n\n\n\n\ndplyr generally produces much easier-to-read code, especially when using the pipe to bring together lines of code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(island) # pick out a column by providing a column name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 1\n   island   \n   <fct>    \n 1 Torgersen\n 2 Torgersen\n 3 Torgersen\n 4 Torgersen\n 5 Torgersen\n 6 Torgersen\n 7 Torgersen\n 8 Torgersen\n 9 Torgersen\n10 Torgersen\n# ℹ 334 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  select(-island) # remove a column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 7\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   <fct>            <dbl>         <dbl>             <int>       <int> <fct> \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            NA            NA                  NA          NA <NA>  \n 5 Adelie            36.7          19.3               193        3450 female\n 6 Adelie            39.3          20.6               190        3650 male  \n 7 Adelie            38.9          17.8               181        3625 female\n 8 Adelie            39.2          19.6               195        4675 male  \n 9 Adelie            34.1          18.1               193        3475 <NA>  \n10 Adelie            42            20.2               190        4250 <NA>  \n# ℹ 334 more rows\n# ℹ 1 more variable: year <int>\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  select(species, flipper_length_mm, island) # select and re-order columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 3\n   species flipper_length_mm island   \n   <fct>               <int> <fct>    \n 1 Adelie                181 Torgersen\n 2 Adelie                186 Torgersen\n 3 Adelie                195 Torgersen\n 4 Adelie                 NA Torgersen\n 5 Adelie                193 Torgersen\n 6 Adelie                190 Torgersen\n 7 Adelie                181 Torgersen\n 8 Adelie                195 Torgersen\n 9 Adelie                193 Torgersen\n10 Adelie                190 Torgersen\n# ℹ 334 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  select(home_island = island) # select and rename\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 1\n   home_island\n   <fct>      \n 1 Torgersen  \n 2 Torgersen  \n 3 Torgersen  \n 4 Torgersen  \n 5 Torgersen  \n 6 Torgersen  \n 7 Torgersen  \n 8 Torgersen  \n 9 Torgersen  \n10 Torgersen  \n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n\nA note here: the `penguins` object that we're working with is technically called a tibble. `dplyr` is specifically adapted to work with tibbles, and many of the functions won't work properly on other kinds of data structure. The main idea underlying `dplyr` is that the many functions it contains should all work consistently, and work well together. So once you've got the hang of `select` there's not much new to say about `filter`, which picks rows based on their values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(species == \"Adelie\") # find some rows about Adelie penguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 152 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 142 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  filter(bill_length_mm > 55) # find the big bills\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Gentoo    Biscoe           59.6          17                 230        6050\n2 Gentoo    Biscoe           55.9          17                 228        5600\n3 Gentoo    Biscoe           55.1          16                 230        5850\n4 Chinstrap Dream            58            17.8               181        3700\n5 Chinstrap Dream            55.8          19.8               207        4000\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  filter(is.na(bill_length_mm)) # find missing data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen             NA            NA                NA          NA\n2 Gentoo  Biscoe                NA            NA                NA          NA\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n\n\nAnd `mutate` - which makes new columns - will work in the same way:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  mutate(new_col = 11) |> # every row the same\n  select(species, new_col) # so that we can see the new values in the preview\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   species new_col\n   <fct>     <dbl>\n 1 Adelie       11\n 2 Adelie       11\n 3 Adelie       11\n 4 Adelie       11\n 5 Adelie       11\n 6 Adelie       11\n 7 Adelie       11\n 8 Adelie       11\n 9 Adelie       11\n10 Adelie       11\n# ℹ 334 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  mutate(bill_vol = bill_length_mm * bill_depth_mm^2) |> # some calculation\n  select(species, bill_vol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   species bill_vol\n   <fct>      <dbl>\n 1 Adelie    13673.\n 2 Adelie    11959.\n 3 Adelie    13057.\n 4 Adelie       NA \n 5 Adelie    13670.\n 6 Adelie    16677.\n 7 Adelie    12325.\n 8 Adelie    15059.\n 9 Adelie    11172.\n10 Adelie    17138.\n# ℹ 334 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins |>\n  mutate(label = paste(\"From\", island, \"island, a penguin of the species\", species)) |>\n  select(label, body_mass_g) # mutate and then select. You can use your new columns immediately.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 2\n   label                                                  body_mass_g\n   <chr>                                                        <int>\n 1 From Torgersen island, a penguin of the species Adelie        3750\n 2 From Torgersen island, a penguin of the species Adelie        3800\n 3 From Torgersen island, a penguin of the species Adelie        3250\n 4 From Torgersen island, a penguin of the species Adelie          NA\n 5 From Torgersen island, a penguin of the species Adelie        3450\n 6 From Torgersen island, a penguin of the species Adelie        3650\n 7 From Torgersen island, a penguin of the species Adelie        3625\n 8 From Torgersen island, a penguin of the species Adelie        4675\n 9 From Torgersen island, a penguin of the species Adelie        3475\n10 From Torgersen island, a penguin of the species Adelie        4250\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n\nAs before, we need to assign with `<-` to save our changes. Let's add the `bill_vol column` to the data now\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_vol <- penguins |>\n  mutate(bill_vol = bill_length_mm * bill_depth_mm^2)\n```\n:::\n\n\n\n\n`arrange` sorts columns:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_vol |>\n  arrange(bill_vol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           42.9          13.1               215        5000\n 2 Gentoo  Biscoe           42            13.5               210        4150\n 3 Gentoo  Biscoe           40.9          13.7               214        4650\n 4 Adelie  Dream            32.1          15.5               188        3050\n 5 Gentoo  Biscoe           43.3          13.4               209        4400\n 6 Gentoo  Biscoe           44.9          13.3               213        5100\n 7 Gentoo  Biscoe           42.6          13.7               213        4950\n 8 Gentoo  Biscoe           42.7          13.7               208        3950\n 9 Gentoo  Biscoe           46.1          13.2               211        4500\n10 Gentoo  Biscoe           44            13.6               208        4350\n# ℹ 334 more rows\n# ℹ 3 more variables: sex <fct>, year <int>, bill_vol <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nThe nice thing about dplyr is that there are several other packages which work in similar ways. This package ecosystem gets called [the tidyverse](https://www.tidyverse.org/), and is extremely widely used to do data science work in R. A close relative of `dplyr` is the `readr` package, which reads in data to R and makes it into tibbles:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readr\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\npenguins_raw <- read_csv(\"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins_raw.csv\")\n```\n:::\n\n\n\n\n# Session 5: graphs with ggplot2\n\nThere are many options for making graphs with R. We'll use the [ggplot2](https://ggplot2.tidyverse.org/index.html) package, which is probably the best balance between power and ease for beginners. We'll install and attach that package in the usual way:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# you may need to install the package\n# install.packages(\"ggplot2\")\n\nlibrary(ggplot2)\n\n# you may also need to load the penguins data\n# library(palmerpenguins)\n```\n:::\n\n\n\n\nIn ggplot, plots are built up in layers. If you take your penguins data, and pipe it to the `ggplot()` function, you'll create a plot, albeit not a very interesting one:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot()\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-63-1.png){width=672}\n:::\n:::\n\n\n\n\nTo make our plot more interesting, we can add layers. We'll add a geom layer now to build a simple [histogram](https://en.wikipedia.org/wiki/Histogram). Geoms describe the type of plot we want to add in a layer. So `geom_line()` adds a line-graph layer, `geom_point()` an XY scatter layer, `geom_col()` a column graph etc etc. Inside that `geom_histogram()` function, we'll use a new function: `aes()`. `aes()` describes hthe relationship between our data and our graph. If we want to produce a histogram of flipper length, for example, we'd put our `geom_histogram()` and our `aes()` together like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() + \n  geom_histogram(aes(x = flipper_length_mm)) # do a histogram of flipper length\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n\n\n\nYou'll also see a slight quirk here about ggplot, which is that we don't use the `|>` pipe with ggplot code. ggplot is older than the pipe, so we need to join lines of code using `+`. Back to `aes()`: if we want to make a similar graph that produces a histogram for a different part of our data, we'll need to change the `aes()`. So a histogram of bill depth would be:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_histogram(aes(x = bill_depth_mm))\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-65-1.png){width=672}\n:::\n:::\n\n\n\n\nBut if we wanted to change the type of graph we produced for that data, we could keep the `aes()` intact, but change the `geom_`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_density(aes(x = bill_depth_mm))\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-66-1.png){width=672}\n:::\n:::\n\n\n\n\nGeoms have lots of options. Set fixed options for that geom outside the `aes()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \npenguins |>\n  ggplot() +\n  geom_density(aes(x = bill_depth_mm), fill = \"hotpink\", alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-67-1.png){width=672}\n:::\n:::\n\n\n\n\nR recognises about 600 colour names. There are [various cheatsheets](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf) on the internet that will help with that. Or you can specify colour more precisely using [hex colour values](https://www.w3schools.com/colors/colors_hexadecimal.asp):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_density(aes(x = bill_depth_mm), fill = \"#4dc3ff\", alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-68-1.png){width=672}\n:::\n:::\n\n\n\n\nDifferent geoms have different options, and can take different aes options to map features of your graph onto your data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_histogram(aes(x = bill_length_mm, fill = species)) # different colours per species\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-69-1.png){width=672}\n:::\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_point(aes(x = bill_length_mm, \n                 y = bill_depth_mm,\n                 colour = species,\n                 shape = species,\n                 size = body_mass_g))\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-69-2.png){width=672}\n:::\n:::\n\n\n\n\nYou can also put several `geom_` layers on one plot. Those layers can have different `aes`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot() +\n  geom_histogram(aes(x = bill_length_mm, fill = species)) +\n  geom_point(aes(x = bill_length_mm, y = bill_depth_mm))\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-70-1.png){width=672}\n:::\n:::\n\n\n\n\n(not sure that plot's showing anything useful at all). Or you can put one call to `aes` inside `ggplot()`, and have all your `geom_` layers inherit:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  ggplot(aes(x = bill_length_mm, \n                 y = bill_depth_mm,\n                 colour = species)) +\n  geom_point() +\n  geom_smooth() # smoothed conditional mean with confidence interval\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-71-1.png){width=672}\n:::\n:::\n\n\n\n\n## Saving plots\n\nYou can save and recall ggplot objects like anything else in R:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot <- penguins |>\n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, colour = species, shape = species)) +\n  geom_point()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-73-1.png){width=672}\n:::\n:::\n\n\n\n\nggplot objects are lists:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(peng_plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"gg\"     \"ggplot\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(peng_plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nInterestingly, the plot object contains the full data used to build the plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot$data # your original data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n\n\nIt's possible, although highly non-advisible, to fiddle with the ggplot object by assigning into it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot$labels$x <- \"huley booley\" \npeng_plot\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-76-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot$labels$x <- \"bill_length_mm\" # restoring order\n```\n:::\n\n\n\n\nThe reason this is interesting and useful is that you can take a saved ggplot, and add extra layers to it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot +\n  geom_smooth() # add extra layers to the saved object\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-78-1.png){width=672}\n:::\n:::\n\n\n\n\n## Styling plots\n\nStyling happens in layers too. Start with labelling, where there are several different possible options:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot +\n  ggtitle(\"A title using ggtitle\") # good if you're only adding a title\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-79-1.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n  xlab(\"Bill length (mm), set using xlab\") # or if you just want to tweak the x-axis label\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-79-2.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n  labs(x = \"Bill length (mm), set using labs\")\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-79-3.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n    labs(title = \"An uninformative title\") # better if you're doing lots of labelling\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-79-4.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n    labs(title = \"An uninformative title\",\n       x = \"Something about Bill Lengths\",\n       subtitle = \"This one here is a subtitle\") \n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-79-5.png){width=672}\n:::\n:::\n\n\n\n\nYou can also theme the entire plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-80-1.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-80-2.png){width=672}\n:::\n:::\n\n\n\n\nEach element can be styled individually. That can become very involved, but some simple and useful examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot +\n  theme_classic(base_size = 18) # embiggen the text\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-81-1.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n  theme_classic() +\n  theme(legend.position = \"none\") # hide the legend\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-81-2.png){width=672}\n:::\n:::\n\n\n\n\nCustomising the plot colours can be done in several ways. For very simple cases, it might be enough to specify a vector of colour names or hex values, which you can then use inside either `scale_fill_manual` or `scale_colour_manual`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_colours <- c(\"#e66101\", \"#b2abd2\", \"#5e3c99\")\n\npeng_plot +\n  scale_colour_manual(values = my_colours) # use scale_colour_manual for geoms that take a colour aesthetic\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-82-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# if you're using a geom that takes a fill, use scale_fill_manual:\n\npenguins |>\n  ggplot() +\n  geom_col(aes(x = species, y = bill_length_mm, fill = species)) +\n  scale_fill_manual(values = my_colours)\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-82-2.png){width=672}\n:::\n:::\n\n\n\n\nManually specifying colours is hard, particularly as you should be considering the likely impacts on accessibility that can result. A stronger general approach is to use [colorbrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) to do the hard work for you:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_plot +\n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-83-1.png){width=672}\n:::\n\n```{.r .cell-code}\npeng_plot +\n  scale_colour_brewer(palette = \"Paired\")\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-83-2.png){width=672}\n:::\n:::\n\n\n\n\nYou can also borrow entire themes from packages, such as ggthemes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"ggthemes\")\nlibrary(ggthemes)\npeng_plot +\n  theme_economist() +\n  scale_colour_economist()\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-84-1.png){width=672}\n:::\n:::\n\n\n\n\n## Data for plots\n\nA final thought: if your ggplot code is becoming very complicated, the usual first check is to see if you can re-work your data to make it easier to plot. A good example is transforming wide data to long-form to simplify aes calls:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyr\")\n# install.packages(\"tibble\")\nlibrary(tidyr)\nlibrary(tibble)\n\nlong_cars <- mtcars |>\n  select(qsec,drat, disp, hp) |>\n  rownames_to_column() |>\n  pivot_longer(-rowname)\n\nlong_cars |>\n  ggplot() +\n  geom_histogram(aes(x = value, fill = name), bins = 5) \n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-85-1.png){width=672}\n:::\n\n```{.r .cell-code}\nlong_cars |>\n  ggplot() +\n  geom_histogram(aes(x = value, fill = name), bins = 5) +\n  facet_wrap(~name, ncol = 1, scales = \"free\") # this can be split into small multiples\n```\n\n::: {.cell-output-display}\n![](r_from_scratch_files/figure-html/unnamed-chunk-85-2.png){width=672}\n:::\n:::\n\n\n\n\n# Session 6: tips, tricks, troubleshooting, and pain-points\n\n## Formatting/refactoring/tidying code\n\nYou'll often need to rework code as you write it. You can think of this similar to the process of drafting, and then editing, and then proof-reading text. There's lots to say about this subject, so we'll stick to a few beginner tips here. But you might also like to look at the set of [R community standards produced by the KIND network](https://nes-dew.github.io/KIND-community-standards/r.html):\n\n### Use `source()`\n\n`source()` allows you to split up long R scripts. If you put some code in a file called `somescript.R`, you can then include that code in another script by writing: `source(somescript.R)`. It's as if you'd pasted the code in, but without the bulk and confusion that can cause.\n\n### Pick a structure and stick to it\n\nFor example, you might go with something like:\n\n1.  script information at the very top\n2.  then package loading\n3.  then data loading\n4.  then function definitions\n5.  ...\n\n### Make your variable names sensible (and hierarchical)\n\nSo if you're working with a set of data about GP practices named `practices`, you might create several derivative variables which would most sensibly be named:\n\n-   `practices_count`\n-   `practices_count_grouped`\n-   `practices_largest`\n-   ...\n\n### Add comments and sections\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# all the code here has been full of comments. Write comments!\n```\n:::\n\n\n\n\n### Find ways of automating the routine stuff\n\nThree packages to know about to help manage your code: [formatR](https://cran.r-project.org/web/packages/formatR/index.html), [styler](https://github.com/r-lib/styler), and [lintr](https://github.com/r-lib/lintr)\n\n## Use projects\n\nYou should work in projects. That's easy to do in Posit Cloud as everything is a project. R projects help keep you organised, and prevent you having to do lots of messy and fallible work in setting working directories, supplying file paths, and wrestling with scripts when you move them.\n\nR thinks about a working directory, which is where it is based at the time it's running. You can use the `getwd()` and `setwd()` to find out, or change, your working directory. But those are better avoided. If you're working in a project, the project root is your working directory.\n\nProjects allow you to use relative paths with confidence - so `\"data/data.csv\"` describes a file named `data.csv` that lives in the `data` subdirectory of your project. Managing full paths is a nuisance in R, especially if you're on Windows. R doesn't like Windows file paths as they include back slashes `\\`. For example:</br>`C:\\my_drive\\my_code\\R_code\\data\\data.csv`. If we want to use that path in R, you'll need to tweak it to deal with the back slashes. You can either double them:</br>`C:\\\\my_drive\\\\my_code\\\\R_code\\\\data\\\\data.csv`</br> or replace them with forward slashes `/`: </br>`C:/my_drive/my_code/R_code/data/data.csv`.\n\nBut definitely better to avoid full paths if at all possible. Projects make scripts portable by allowing you to ignore details specific to your computer that are hard-coded into paths etc etc. Sharing code is a key advantage of R, and you should make that as easy and fun as possible\n\n## Error messages\n\nSome error messages - mainly those from newer functions - are nice and informative, and can even suggest ways of resolving the problem:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(1 + \"two\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in 1 + \"two\" : non-numeric argument to binary operator\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(readr::read_csv(\"nope.csv\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError : 'nope.csv' does not exist in current working directory ('C:/Users/brendancl/not_od/KIND-training/r_training').\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(penguins |> ggplot() |> geom_density(aes(y = flipper_length_mm)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in geom_density(ggplot(penguins), aes(y = flipper_length_mm)) : \n  `mapping` must be created by `aes()`.\nℹ Did you use `%>%` or `|>` instead of `+`?\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(log(-1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n\n\nOthers are unfortunately a bit more opaque:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#\ntry(na_numbers[10,]) # vectors are, I suppose, 1-dimensional\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in eval(expr, envir, enclos) : object 'na_numbers' not found\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(Sum(3,4,5)) # remember the capitals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in Sum(3, 4, 5) : could not find function \"Sum\"\n```\n\n\n:::\n:::\n\n\n\n\nBut the worst are the non-error errors - e.g. where the code won't even run well enough to have an error. A nice example is when your console is showing an +, rather than a >, which means means that R is waiting for input, and usually means there's a missing bracket somewhere.\n\nAnother one to watch out for: there are a couple of different filter functions. If a filter isn't working well, it's always worth specifying which filter you want with `dplyr::filter` (or much more rarely `stats::filter`),\n\n## How to read data into, and out of, Excel, pdf, Word, etc...\n\nThere are a couple of different areas to think about here. Reading data to and from Excel is the most straightforward:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"readxl\")\nlibrary(readxl)\n# install.packages(\"readr\")\nlibrary(readr)\nlibrary(dplyr)\n\nread_xlsx(\"data/my_dat.xlsx\") # to read data in from Excel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  name      values\n  <chr>      <dbl>\n1 Elizabeth      8\n2 Lorah          7\n3 Eilish        10\n4 Colin          6\n5 Robert         1\n```\n\n\n:::\n\n```{.r .cell-code}\nread_csv(\"data/my_dat.csv\") |>\n  mutate(total = value1 + value2) |>\n  write_csv(\"data/my_output_dat.csv\") # to write data back to csv, which can be opened in Excel\n```\n:::\n\n\n\n\nYou can also scale this up to read several files at once:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"data/multifile\", full.names = T) |>\n  readr::read_csv()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 3\n   name      value1 value2\n   <chr>      <dbl>  <dbl>\n 1 Elizabeth      8      7\n 2 Lorah          7      5\n 3 Eilish        10      7\n 4 Colin          6     41\n 5 Robert         1     99\n 6 Elizabeth      8      7\n 7 Lorah          7      5\n 8 Eilish        10      7\n 9 Colin          6      4\n10 Robert         1     99\n11 Elizabeth      8      7\n12 Lorah          7      5\n13 Eilish        10      7\n14 Colin          6      4\n15 Robert         1     99\n16 Elizabeth      8      7\n17 Lorah          7      5\n18 Eilish        10      7\n19 Colin          6      4\n20 Robert         1     99\n```\n\n\n:::\n:::\n\n\n\n\nOr use a pattern option to only read some files:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"data/\", \n           full.names = T, \n           pattern = \"my_\",\n           recursive = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data/multifile/my_dat - v1.csv\" \"data/multifile/my_dat - v2.csv\"\n[3] \"data/multifile/my_dat - v3.csv\" \"data/multifile/my_dat - v4.csv\"\n[5] \"data/my_dat.csv\"                \"data/my_dat.xlsx\"              \n[7] \"data/my_output_dat.csv\"        \n```\n\n\n:::\n:::\n\n\n\n\n\nWriting back to a proper .xlsx file is much more involved. A good place to start would be the [openxlsx package](https://ycphs.github.io/openxlsx/), although note that this can become quite involved pretty easily. [Excel files are surprisingly complicated](https://www.joelonsoftware.com/2008/02/19/why-are-the-microsoft-office-file-formats-so-complicated-and-some-workarounds/)...\n\nSimilarly, if you need to read/write Word documents, you're going to need some packages. For Word, [docxtractr](https://cran.r-project.org/web/packages/docxtractr/index.html) (as the name suggests) is helpful for extracting data, while [flextable](https://ardata-fr.github.io/flextable-book/) can be used to help write to docx:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"docxtractr\")\n# install.packages(\"flextable\")\n\nlibrary(docxtractr)\nlibrary(flextable)\n\nmtcars |>\n  flextable() |>\n  save_as_docx(path = \"data/word.docx\") # to write some data\n```\n:::\n\n\n\n\n![Data in Word](images/clipboard-1849315505.png)\n\nWe can then read this data back to show how extraction might work:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_from_word <- docxtractr::read_docx(\"data/word.docx\")\n```\n:::\n\n\n\n\nBut, unlike Excel, we need to do some additional work to extract our data. docxtractr has identified a table, so we can convert that back into a tibble to get at its contents:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_from_word |>\n  docxtractr::docx_extract_tbl() |>\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|mpg  |cyl |disp  |hp  |drat |wt    |qsec  |vs |am |gear |carb |\n|:----|:---|:-----|:---|:----|:-----|:-----|:--|:--|:----|:----|\n|21.0 |6   |160.0 |110 |3.90 |2.620 |16.46 |0  |1  |4    |4    |\n|21.0 |6   |160.0 |110 |3.90 |2.875 |17.02 |0  |1  |4    |4    |\n|22.8 |4   |108.0 |93  |3.85 |2.320 |18.61 |1  |1  |4    |1    |\n|21.4 |6   |258.0 |110 |3.08 |3.215 |19.44 |1  |0  |3    |1    |\n|18.7 |8   |360.0 |175 |3.15 |3.440 |17.02 |0  |0  |3    |2    |\n|18.1 |6   |225.0 |105 |2.76 |3.460 |20.22 |1  |0  |3    |1    |\n|14.3 |8   |360.0 |245 |3.21 |3.570 |15.84 |0  |0  |3    |4    |\n|24.4 |4   |146.7 |62  |3.69 |3.190 |20.00 |1  |0  |4    |2    |\n|22.8 |4   |140.8 |95  |3.92 |3.150 |22.90 |1  |0  |4    |2    |\n|19.2 |6   |167.6 |123 |3.92 |3.440 |18.30 |1  |0  |4    |4    |\n|17.8 |6   |167.6 |123 |3.92 |3.440 |18.90 |1  |0  |4    |4    |\n|16.4 |8   |275.8 |180 |3.07 |4.070 |17.40 |0  |0  |3    |3    |\n|17.3 |8   |275.8 |180 |3.07 |3.730 |17.60 |0  |0  |3    |3    |\n|15.2 |8   |275.8 |180 |3.07 |3.780 |18.00 |0  |0  |3    |3    |\n|10.4 |8   |472.0 |205 |2.93 |5.250 |17.98 |0  |0  |3    |4    |\n|10.4 |8   |460.0 |215 |3.00 |5.424 |17.82 |0  |0  |3    |4    |\n|14.7 |8   |440.0 |230 |3.23 |5.345 |17.42 |0  |0  |3    |4    |\n|32.4 |4   |78.7  |66  |4.08 |2.200 |19.47 |1  |1  |4    |1    |\n|30.4 |4   |75.7  |52  |4.93 |1.615 |18.52 |1  |1  |4    |2    |\n|33.9 |4   |71.1  |65  |4.22 |1.835 |19.90 |1  |1  |4    |1    |\n|21.5 |4   |120.1 |97  |3.70 |2.465 |20.01 |1  |0  |3    |1    |\n|15.5 |8   |318.0 |150 |2.76 |3.520 |16.87 |0  |0  |3    |2    |\n|15.2 |8   |304.0 |150 |3.15 |3.435 |17.30 |0  |0  |3    |2    |\n|13.3 |8   |350.0 |245 |3.73 |3.840 |15.41 |0  |0  |3    |4    |\n|19.2 |8   |400.0 |175 |3.08 |3.845 |17.05 |0  |0  |3    |2    |\n|27.3 |4   |79.0  |66  |4.08 |1.935 |18.90 |1  |1  |4    |1    |\n|26.0 |4   |120.3 |91  |4.43 |2.140 |16.70 |0  |1  |5    |2    |\n|30.4 |4   |95.1  |113 |3.77 |1.513 |16.90 |1  |1  |5    |2    |\n|15.8 |8   |351.0 |264 |4.22 |3.170 |14.50 |0  |1  |5    |4    |\n|19.7 |6   |145.0 |175 |3.62 |2.770 |15.50 |0  |1  |5    |6    |\n|15.0 |8   |301.0 |335 |3.54 |3.570 |14.60 |0  |1  |5    |8    |\n|21.4 |4   |121.0 |109 |4.11 |2.780 |18.60 |1  |1  |4    |2    |\n\n\n:::\n:::\n\n\n\n\nReading data from pdf is much more involved, and I'd suggest exploring the [pdftools package](https://cran.r-project.org/web/packages/pdftools/index.html) as a starting point.\n\nAn alternative strategy if you need to write a lot of Word/pdf documents would be Rmarkdown or Quarto. These enable you to embed R code in a proper document production tool, which is great for writing regular reports.\n\n## How to read and analyze free text?\n\nThere's a really nice set of tools for text analysis in the [tidytext package](https://cran.r-project.org/web/packages/tidytext/vignettes/tidytext.html):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidytext\") # main tidytext package\nlibrary(tidytext)\n#install.packages(\"stopwords\") # to help remove common small words\nlibrary(stopwords)\n# install.packages(\"janeaustenr\") # for some sample text\nlibrary(janeaustenr)\n\nausten_books() |>\n  unnest_tokens(input = text, output = word) |>\n  anti_join(get_stopwords()) |> # remove small common words\n  count(word, sort = T) |>\n  slice_max(n, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  word      n\n  <chr> <int>\n1 mr     3015\n2 mrs    2446\n3 must   2071\n4 said   2041\n5 much   1935\n```\n\n\n:::\n:::\n\n\n\n:::\n\n<!--  the main tabset, so leave well alone and work within please -->\n",
    "supporting": [
      "r_from_scratch_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}