{
  "hash": "f7b760b7848513a1b0802dd167333887",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R from scratch\"\ndate: 2024-09-03\nexecute: \n  echo: true\n  eval: true\n  freeze: auto\n  output: \"markup\"\ncategories: [R, beginner]\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Getting started\n\n-   you'll need some kind of R setup for this training\n    -   if you already have some type of R installation available (PHS workbench, Rstudio desktop etc) please feel free to use that\n    -   otherwise, create a free account on [posit.cloud](https://posit.cloud/ \"https://posit.cloud/\")\n-   Then confirm that you're able to log-in to that account using the device and the network connection that you're going to be using during the training session. Of note, some board VPNs (PHS, Lothian, couple of others) seem to cause trouble, and it can take a bit of time to work out fixes and workarounds.\n-   Once logged in, please attempt a 2 minute test (below) so that we can be sure everything will be in working order before the first training session:\n\n:::{.callout-note collapse=true appearance='default' icon=true}\n## Testing your Posit Cloud\n1. sign in to your account at <https://posit.cloud/>\n1. create a New RStudio Project from the big blue button</br> ![create a New RStudio Project](images/clipboard-1870431838.png)\n1. after 30 seconds or so you should have a new R project open in front of you</br>![new R project](images/clipboard-3686794244.png)\n1. in the console - the bottom-left part of the window with all the text in - please type `demo(image)` at the `>` prompt and press enter\n1. keep pressing enter until you see graphs start appearing (2-3 times should do it)</br>![demo plots](images/clipboard-984098222.png)\n:::\n\n\n# Session 1: \"hello world\"\n\n## hello world\n\n-   R has a terminal where you can write code, and R will run it for you and show you the results\n-   we'll start with a string, which is how we keep words in R code (single or double quotes, your choice)\n-   type a string in the terminal\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n![](images/clipboard-1008380297.png)\n\n-   but we usually write R in script files\n-   start a new R scr![](images/clipboard-4056129341.png)\n-   now press `Ctrl` + `Enter` to run your script\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n-   (for the coders, R has implicit print)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# variable\n# assignment operator\nhw <- \"hello world\"\nhw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# R is case sensitive\n# R runs from top to bottom - you can't use an object until you've made it\ntry(HW) # a way of running broken code and capturing the error messages it provokes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in eval(expr, envir, enclos) : object 'HW' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nHW <- \"HELLO WORLD\"\nHW\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO WORLD\"\n```\n\n\n:::\n:::\n\n\n## functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print function\n# variables persist\nprint(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# help for all functions\n?print\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# look at the help and try to make substr work to pull out \"hello\"\n# arguments\nsubstr(hw, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# return value\n# assign out of functions\nhi <- substr(hw, 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# combine\nc(hw, hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\" \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(c(hw, hw))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# most functions are vectorised\nsubstr(c(hw, hw), 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhh <- substr(c(hw, hw), 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# especially nice for maths stuff\n# logic\nc(4,3,7,55) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   8   6  14 110\n```\n\n\n:::\n\n```{.r .cell-code}\nc(4,3,7,55) > 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexing\n# range operator\nhh[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"  \"indexing\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#length\n# typeof\nlength(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## data types and classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# homogenous - only one kind of thing per vector\ntypeof(\"this is a string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# factors - the odd one\n# mainly a way of storing categorical data, especially when you need it in non-alphabetical order\nfactor(c(\"thing\", \"string\", \"wing\", \"bling\")) # alphabetical\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: bling string thing wing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things <- factor(c(\"thing\", \"string\", \"wing\", \"bling\"), levels = c(\"wing\", \"bling\", \"string\", \"thing\")) # alphabetical\ning_things\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] string\nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the list = a vector of vectors\n# ragged - can store different kinds of values together\nlist(hh, hi, hw, ing_things)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\" \"hello\"\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[1] \"hello world\"\n\n[[4]]\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# names\nnamed_list <- list(\"hw\" = hh, \n                   \"hi\" = hi, \n                   \"hw\" = hw, \n                   \"silly_name\" = ing_things)\nnamed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$hw\n[1] \"hello\" \"hello\"\n\n$hi\n[1] \"hello\"\n\n$hw\n[1] \"hello world\"\n\n$silly_name\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different indexing required for lists\nclass(named_list[4]) #gets you a smaller list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# two easy ways of getting vectors out of lists\nnamed_list$silly_name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list[[4]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# and you can flatten a list into a vector\nunlist(named_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          hw1           hw2            hi            hw   silly_name1 \n      \"hello\"       \"hello\"       \"hello\" \"hello world\"           \"4\" \n  silly_name2   silly_name3   silly_name4 \n          \"3\"           \"1\"           \"2\" \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}