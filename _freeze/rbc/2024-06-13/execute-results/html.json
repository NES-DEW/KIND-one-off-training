{
  "hash": "b5d37d8a1238342d93feacb169b9e015",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R beginner's club 2024-06-13\nexecute: \n  output: markdown\n  echo: true\n---\n\n\n## How to compare two (or more) Excel spreadsheets?\n\nThe basic recipe here is:\n\n1. read our Excel spreadsheets into R\n1. try some simple base-R methods of comparison\n1. get more fancy with packages for more useful comparisons\n\n### Reading in Excel files\n\nThis can be messy. `readxl` is probably the most straightforward place to start. Make sure a) that your Excel files aren't open in Excel when you try to read them and b) that you're happy and confident that your data is on the first worksheet (or you know the correct name of the sheet). You'll almost certainly want to be working in an R project too to avoid too much messing around with file paths, `getwd()`, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl) # to attach the readxl package\nb1 <- read_xlsx(\"data/Book1.xlsx\") \nb2 <- read_xlsx(\"data/Book2.xlsx\") # to read the files\n```\n:::\n\n\n### Basic comparisons\n\nThe most obvious thing to try first is a check for equality. You'll do this with a **double** equal sign, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb1 == b2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name score\n [1,] TRUE  TRUE\n [2,] TRUE  TRUE\n [3,] TRUE  TRUE\n [4,] TRUE  TRUE\n [5,] TRUE  TRUE\n [6,] TRUE  TRUE\n [7,] TRUE  TRUE\n [8,] TRUE  TRUE\n [9,] TRUE  TRUE\n[10,] TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n(single `=` is effectively the same as `<-`)\n\nThat gives us back quite a complicated matrix of results, showing a cell-by-cell comparison of the two sets of data. This happens because R is *vectorised* - so when we compare two identically-shaped bits of data, R will assume that we want to do our comparison to each of the items in turn. If we just looked at the number values in our spreadsheets, which we could do by using the `$` to refer to a column, we could:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb1$score - b2$score\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\nWhich I suppose is another way of checking for equality. So could also use a helper function to collapse all of those down into one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(b1$score - b2$score)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nIf we just wanted a simple true/false measure for the data as a whole, we could recruit the very useful `all()` and `any()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(b1 == b2) # to check all values are the same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nany(b1 == b2) # to check any values are the same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nYou could do something very similar using `setequal()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetequal(b1, b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n### More interesting comparisons\n\n`waldo::compare()` is a brilliant way of comparing complex data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(b1, b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n:::\n\n\nIf we vandalise one of our datasets by changing one value, waldo does plenty of useful work to bring the correct parts of the data to our attention:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb2[5,2] <- 1\nwaldo::compare(b1, b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nold vs new\n                score\n  old[2, ]  0.2481382\n  old[3, ]  0.6444191\n  old[4, ]  0.8873743\n- old[5, ]  0.3361401\n+ new[5, ]  1.0000000\n  old[6, ]  0.1597596\n  old[7, ]  0.3928778\n  old[8, ]  0.5743370\n\n`old$score[2:8]`: 0.2 0.6 0.9 0.3 0.2 0.4 0.6\n`new$score[2:8]`: 0.2 0.6 0.9 1.0 0.2 0.4 0.6\n```\n\n\n:::\n:::\n\n\nI suppose we could also graph our data to show changed points. One way of doing this is to plot the two sets in different colours:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot() +\n  geom_point(data = b1, aes(x = name, y = score), colour = \"red\", size = 5) +\n  geom_point(data = b2, aes(x = name, y = score), colour = \"blue\", size = 5)\n```\n\n::: {.cell-output-display}\n![](2024-06-13_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nOr, possibly more elegantly, we could join our data using dplyr, then subtract one from the other, then plot the difference:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nb1 |>\n  left_join(b2, by = \"name\") |>\n  ggplot(aes(x = name, xend = name, y = score.y - score.x, yend = 0), colour = \"red\") +\n  geom_segment() +\n  geom_label(aes(label = name))\n```\n\n::: {.cell-output-display}\n![](2024-06-13_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n## How to think about joins?\n\nWe did a simple join above. A join is a way of merging two datasets. Let's demonstrate with some cut-down datasets from above. We'll remove some of the values from our `b1` set and from our `b2` set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb1 <- b1 |>\n  slice(1:5)\n\nb1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  name     score\n  <chr>    <dbl>\n1 kennedy  0.590\n2 victoria 0.248\n3 peter    0.644\n4 judi     0.887\n5 paul     0.336\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb2 <- b2 |>\n  slice_sample(n = 5)\n\nb2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  name     score\n  <chr>    <dbl>\n1 jennifer 0.160\n2 alupha   0.574\n3 victoria 0.248\n4 paul     1    \n5 judi     0.887\n```\n\n\n:::\n:::\n\n\nThe simplest join we could do is to bind the rows from one set onto another:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb1 |>\n  bind_rows(b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   name     score\n   <chr>    <dbl>\n 1 kennedy  0.590\n 2 victoria 0.248\n 3 peter    0.644\n 4 judi     0.887\n 5 paul     0.336\n 6 jennifer 0.160\n 7 alupha   0.574\n 8 victoria 0.248\n 9 paul     1    \n10 judi     0.887\n```\n\n\n:::\n:::\n\nThat just brings all the rows from `b2` onto the end of `b1`. Unlike binding, though, in a join we usually want to only include some of our values. So let's now left-join `b2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb1 |>\n  left_join(b2, by = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  name     score.x score.y\n  <chr>      <dbl>   <dbl>\n1 kennedy    0.590  NA    \n2 victoria   0.248   0.248\n3 peter      0.644  NA    \n4 judi       0.887   0.887\n5 paul       0.336   1    \n```\n\n\n:::\n:::\n\n\nYou should see that only the values from `b2`'s score column that have a corresponding name in `b1` get populated, and everything else gets filled with NAs. Here's a [nice introduction to the different kinds of join you can do in dplyr](https://lindsaydbrin.github.io/CREATE_R_Workshop/Lesson_-_dplyr_join.html).\n\n\n",
    "supporting": [
      "2024-06-13_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}